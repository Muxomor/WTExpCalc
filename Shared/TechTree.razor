@using WTExpCalc.Models
@using WTExpCalc.Services
@inject IExperienceApi Api
@inject IJSRuntime JSRuntime

    <div class="tech-tree-container @LoadingState" id="tech-tree-container-id">
    @if (GridNodes.Any())
    {
                <div class="tree-grid" style="@GridStyles">
            @{
                var activeRanks = GetActiveRanks();
                var cumulativeRowsBefore = new Dictionary<int, int>();

                if (activeRanks.Any() && MaxRowIndexPerRank != null)
                {
                    int currentCumulativeRowCount = 0;
                    foreach (var rank in activeRanks)
                    {
                        cumulativeRowsBefore[rank] = currentCumulativeRowCount;
                        int rowsInRankR = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        currentCumulativeRowCount += rowsInRankR;
                    }
                }

                // Отрисовываем только активные ранги
                foreach (var rank in activeRanks)
                {
                    int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                    int startGridRow = 2 + (cumulativeRowsBefore.TryGetValue(rank, out var cumRows) ? cumRows : 0);
                    string rankLabelStyle = $"grid-column: 1; grid-row: {startGridRow} / span {rowsInThisRank};";
                    var requirement = rankRequirements.FirstOrDefault(r => r.PreviousRank == rank);
                    int requiredCount = requirement?.RequiredUnits ?? 0;
                    int selectedCount = AllNodesFlat.Count(n => n.Rank == rank && n.Type == "vehicle" && selectedNodeIds.Contains(n.Id)); 

                                            <div class="rank-label" style="@rankLabelStyle">
                                                <span>Ранг @rank</span>
                        @if (requirement != null)
                        {
                                                            <span class="rank-requirement-counter @(selectedCount >= requiredCount ? "req-met" : "req-not-met")">
                                @selectedCount / @requiredCount
                                                            </span>
                        }
                                            </div>
                }
            }

            @foreach (var node in GridNodes)
            {
                                <div @key="node.Id" class="@GetNodeCssClass(node)" style="@GetNodeGridStyle(node)" id="node-container-@node.Id">
                    @if (node.Type == "folder")
                    {
                        @RenderFolderNode(node)
                    }
                    else
                    {
                        @RenderVehicleNode(node)
                    }
                                </div>
            }

                    <svg class="tree-connections-overlay" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 0;">
                @if (Dependencies != null)
                {
                    @foreach (var dep in Dependencies)
                    {
                                                <line id="dep-@dep.NodeId-@dep.PrerequisiteNodeId"
                                                x1="0" y1="0" x2="0" y2="0"
                                                stroke="#cccccc" stroke-width="2"
                                                marker-end="url(#arrowhead)"
                                                visibility="hidden" />
                    }
                                    <defs>
                                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                                        refX="10" refY="3.5" orient="auto">
                                            <polygon points="0 0, 10 3.5, 0 7" fill="#cccccc" />
                                        </marker>
                                    </defs>
                }
                    </svg>
            @{
                var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
                int maxStdColIndex = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
                int standardColumnCount = Math.Max(0, maxStdColIndex + 1);
                int premiumDividerColumn = 2 + standardColumnCount;

                int lastDataRow = 1 + TotalDataGridRows;

                //Вертикальный разделитель (Премы)
                var premiumNodesExist = AllNodesFlat.Any(n => n.TechCategory != "standard");
                if (premiumNodesExist && standardColumnCount > 0)
                {
                    string premiumDividerStyle = $"grid-column: {premiumDividerColumn}; grid-row: 2 / {lastDataRow + 1};";
                                            <div class="premium-divider-v" style="@premiumDividerStyle"></div>
                }

                //Горизонтальные разделители (только между активными рангами)
                for (int i = 0; i < activeRanks.Count - 1; i++)
                {
                    var currentRank = activeRanks[i];
                    int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(currentRank, out var maxRowIdx) ? maxRowIdx : 0) + 1;
                    int startGridRowCurrentRank = 2 + (cumulativeRowsBefore.TryGetValue(currentRank, out var cumRows) ? cumRows : 0);
                    int endGridRowCurrentRank = startGridRowCurrentRank + rowsInThisRank - 1;

                    string rankDividerStyle = $"grid-column: 2 / -1; grid-row: {endGridRowCurrentRank + 1};";
                                            <div class="rank-divider-h" style="@rankDividerStyle"></div>
                }
            }

                </div>
        @if (currentlyExpandedFolder != null)
        {
                            <div class="folder-popup-overlay" @onclick="CloseFolderPopup"></div>
        }

        @if (currentlyExpandedFolder != null)
        {
                            <div class="folder-popup" id="folder-popup-@currentlyExpandedFolder.Id" style="position:absolute; visibility: hidden;" @key="currentlyExpandedFolder.Id" @onclick:stopPropagation="true">
                                <div class="folder-popup-content">
                    @foreach (var child in GetVisualNodesInFolderSequence(currentlyExpandedFolder))
                    {
                        if (child.Type == "vehicle")
                        {
                                                            <div class="folder-popup-item">
                                @RenderVehicleNode(child)
                                                            </div>
                        }
                    }
                                </div>
                            </div>
        }
    }
    else if (LoadingState != "loading")
    {
                <p>Нет данных для отображения.</p>
    }

    @if (LoadingState == "loading")
    {
                <p>Загрузка...</p>
    }
    @if (LoadingState == "error")
    {
                <p style="color: red;">Ошибка загрузки данных!</p>
    }
</div>

@code {
    [Parameter] public int NationId { get; set; }
    [Parameter] public int TypeId { get; set; }
    [Parameter] public EventCallback<TotalsUpdateEventArgs> OnTotalsUpdated { get; set; }

    private List<Node> AllNodesFlat = new();
    private Dictionary<int, Node> NodeLookup = new();
    private List<Node> GridNodes = new();
    private List<NodeDependency> Dependencies = new();
    private Node? currentlyExpandedFolder;
    private string LoadingState = "loading";
    private List<RankRequirement> rankRequirements = new();
    private HashSet<int> selectedNodeIds = new();
    private int MaxRank = 0;
    private string GridStyles = "";
    private Dictionary<int, int> MaxRowIndexPerRank = new();
    private int TotalDataGridRows = 0;
    private long totalSelectedRp = 0;
    private long totalSelectedSl = 0;

    // Словарь для хранения исходных значений RP
    private Dictionary<int, int?> originalRpValues = new();

    private int _previousNationId = -1;
    private int _previousTypeId = -1;
    private bool _isFirstLoad = true;

    public class TotalsUpdateEventArgs : EventArgs
    {
        public long TotalRp { get; set; }
        public long TotalSl { get; set; }
        public string SelectedNames { get; set; } = string.Empty;
        public string FormattedText { get; set; } = string.Empty;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (LoadingState == "loaded" && Dependencies.Any())
        {
            await Task.Delay(50);
            await DrawConnectionLines();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isFirstLoad || NationId != _previousNationId || TypeId != _previousTypeId)
        {
            _previousNationId = NationId;
            _previousTypeId = TypeId;
            _isFirstLoad = false;

            await LoadData();
        }
    }

    private async Task LoadData()
    {
        try
        {
            LoadingState = "loading";
            MaxRowIndexPerRank.Clear();
            GridNodes.Clear();
            Dependencies.Clear();
            rankRequirements.Clear();
            selectedNodeIds.Clear();
            originalRpValues.Clear(); // Очищаем исходные значения
            currentlyExpandedFolder = null;
            StateHasChanged();

            AllNodesFlat = await Api.GetAllNodesFlatAsync(NationId, TypeId);
            if (AllNodesFlat == null || !AllNodesFlat.Any())
            {
                MaxRank = 0;
                GridStyles = "";
                LoadingState = "loaded";
                StateHasChanged();
                return;
            }

            // Сохраняем исходные значения RP
            foreach (var node in AllNodesFlat)
            {
                if (node.RequiredExp.HasValue)
                {
                    originalRpValues[node.Id] = node.RequiredExp.Value;
                }
            }

            rankRequirements = await Api.GetRankRequirementsAsync(NationId, TypeId);

            NodeLookup = AllNodesFlat.ToDictionary(n => n.Id);
            PrepareGridNodesAndCalculateRows();
            Dependencies = await Api.GetAllDependenciesAsync(NationId, TypeId);
            CalculateGridDimensions();
            LoadingState = "loaded";
            await CalculateAndUpdateTotals();
        }
        catch (Exception ex)
        {
            totalSelectedRp = 0;
            totalSelectedSl = 0;
            if (OnTotalsUpdated.HasDelegate)
            {
                await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs { TotalRp = 0, TotalSl = 0 });
            }
        }
        StateHasChanged();
    }

    private async Task CalculateAndUpdateTotals()
    {
        totalSelectedRp = 0;
        totalSelectedSl = 0;
        var nameList = new List<string>();

        // Получаем выбранные узлы с опытом
        var selectedNodes = selectedNodeIds
            .Select(id => NodeLookup.TryGetValue(id, out var node) ? node : null)
            .Where(node => node != null && node.RequiredExp.HasValue)
            .ToList();

        foreach (var node in selectedNodes)
        {
            long rpValue = node!.RequiredExp ?? 0;
            long slValue = node.SilverCost ?? 0;
            totalSelectedRp += rpValue;
            totalSelectedSl += slValue;
            nameList.Add(node.Name);
        }

        string namesString = string.Join(", ", nameList);
        string formattedText = FormatVehicleListForCopy(selectedNodes!);

        if (OnTotalsUpdated.HasDelegate)
        {
            await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs
                {
                    TotalRp = totalSelectedRp,
                    TotalSl = totalSelectedSl,
                    SelectedNames = namesString,
                    FormattedText = formattedText
                });
        }
    }

    private string FormatVehicleListForCopy(List<Node> selectedNodes)
    {
        if (!selectedNodes.Any()) return "";

        // Группируем по рангам и сортируем внутри каждого ранга по колонке
        var groupedByRank = selectedNodes
            .GroupBy(n => n.Rank)
            .OrderBy(g => g.Key)
            .ToList();

        var result = new List<string>();

        foreach (var rankGroup in groupedByRank)
        {
            var rankNumber = rankGroup.Key;
            var vehiclesInRank = rankGroup
                .OrderBy(n => n.ColumnIndex ?? 0)
                .ToList();

            var vehicleNames = new List<string>();

            foreach (var vehicle in vehiclesInRank)
            {
                string vehicleName = vehicle.Name;

                // Проверяем, изменено ли значение RP
                if (IsRpValueModified(vehicle))
                {
                    var currentRp = vehicle.RequiredExp ?? 0;
                    var originalRp = originalRpValues.TryGetValue(vehicle.Id, out var orig) ? orig ?? 0 : 0;
                    vehicleName += $" ({currentRp} из {originalRp})";
                }

                vehicleNames.Add(vehicleName);
            }

            // Формируем строку для ранга
            string rankLine = $"Ранг {ToRomanNumeral(rankNumber)}:\n{string.Join(", ", vehicleNames)}";
            result.Add(rankLine);
        }

        return string.Join("\n\n", result);
    }

    private string ToRomanNumeral(int number)
    {
        return number switch
        {
            1 => "I",
            2 => "II",
            3 => "III",
            4 => "IV",
            5 => "V",
            6 => "VI",
            7 => "VII",
            8 => "VIII",
            _ => number.ToString()
        };
    }

    private void PrepareGridNodesAndCalculateRows()
    {
        GridNodes.Clear();
        MaxRowIndexPerRank.Clear();
        TotalDataGridRows = 0;

        if (AllNodesFlat == null || !AllNodesFlat.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            int currentMax = MaxRowIndexPerRank.TryGetValue(node.Rank, out var max) ? max : -1;
            if ((node.RowIndex ?? 0) > currentMax) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
            else if (!MaxRowIndexPerRank.ContainsKey(node.Rank)) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
        }
        TotalDataGridRows = MaxRowIndexPerRank.Sum(kvp => kvp.Value + 1);

        foreach (var node in AllNodesFlat)
        {
            bool isGridNode = false;

            if (node.Type == "folder")
            {
                isGridNode = true;
            }
            else if (node.Type == "vehicle")
            {
                if (!node.OrderInFolder.HasValue)
                {
                    isGridNode = true;
                }
            }
            if (isGridNode)
            {
                GridNodes.Add(node);
            }
        }
    }

    private void CalculateGridDimensions()
    {
        MaxRank = AllNodesFlat.Any() ? AllNodesFlat.Max(n => n.Rank) : 0;
        var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
        int maxStd = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        var premiumNodes = AllNodesFlat.Where(n => n.TechCategory != "standard");
        int maxPrem = premiumNodes.Any() ? premiumNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        int stdCount = Math.Max(0, maxStd + 1);
        int premCount = Math.Max(0, maxPrem + 1);

        string gridRowsStyle = "auto";
        if (TotalDataGridRows > 0)
            gridRowsStyle += $" repeat({TotalDataGridRows}, minmax(80px, auto))";
        else if (MaxRank > 0)
            gridRowsStyle += $" repeat({MaxRank}, minmax(80px, auto))";

        GridStyles =
            $"display: grid; " +
            $"grid-template-rows: {gridRowsStyle}; " +
            $"grid-template-columns: auto {(stdCount > 0 ? $"repeat({stdCount}, minmax(100px, auto)) " : "")}{(premCount > 0 ? $"repeat({premCount}, minmax(100px, auto))" : "")}; " +
            $"gap: 30px 40px; position: relative;";
    }

    private List<int> GetActiveRanks()
    {
        // Получаем ранги из rankRequirements и из техники
        var ranksFromRequirements = rankRequirements.Select(r => r.PreviousRank).ToHashSet();
        var ranksFromNodes = AllNodesFlat.Select(n => n.Rank).ToHashSet();

        // Объединяем и сортируем
        var allActiveRanks = ranksFromRequirements.Union(ranksFromNodes).OrderBy(r => r).ToList();

        return allActiveRanks;
    }

    private string GetNodeGridStyle(Node node)
    {
        var activeRanks = GetActiveRanks();

        int col = node.TechCategory == "standard"
            ? 1 + (node.ColumnIndex ?? 0) + 1
            : 1 + ((AllNodesFlat.Where(n => n.TechCategory == "standard").Max(n => n.ColumnIndex ?? 0)) + 1) + (node.ColumnIndex ?? 0) + 1;

        // Вычисляем строку на базе активных рангов
        int calculatedRow = 1;
        foreach (var activeRank in activeRanks)
        {
            if (activeRank >= node.Rank) break;
            calculatedRow += (MaxRowIndexPerRank.TryGetValue(activeRank, out var prev) ? prev : 0) + 1;
        }
        calculatedRow += (node.RowIndex ?? 0);

        return $"grid-column: {col}; grid-row: {calculatedRow + 1}; z-index:1; position:relative;";
    }

    private string GetNodeCssClass(Node node)
    {
        return $"tree-grid-item node-type-{node.Type} tech-cat-{node.TechCategory}";
    }

    private async Task HandleNodeClick(Node node)
    {
        if (node.Type != "folder") return;

        if (currentlyExpandedFolder?.Id == node.Id)
        {
            currentlyExpandedFolder = null;
        }
        else
        {
            currentlyExpandedFolder = node;
        }

        StateHasChanged();

        if (currentlyExpandedFolder != null)
        {
            await Task.Delay(10);
            try
            {
                await JSRuntime.InvokeVoidAsync("techTreeFunctions.positionFolderPopup",
                    $"folder-popup-{currentlyExpandedFolder.Id}",
                    $"node-{currentlyExpandedFolder.Id}",
                    "tech-tree-container-id"
                );
            }
            catch (Exception ex) { }
        }
    }

    private void CloseFolderPopup()
    {
        if (currentlyExpandedFolder != null)
        {
            currentlyExpandedFolder = null;
            StateHasChanged();
        }
    }

    private async Task ToggleNodeSelection(Node node)
    {
        if (node.Type != "vehicle") return;

        if (currentlyExpandedFolder != null)
        {
            var nodesInCurrentPopup = GetVisualNodesInFolderSequence(currentlyExpandedFolder)
                                        .Where(n => n.Type == "vehicle")
                                        .Select(n => n.Id)
                                        .ToHashSet();

            if (!nodesInCurrentPopup.Contains(node.Id))
            {
                currentlyExpandedFolder = null;
            }
        }

        bool isSelected = selectedNodeIds.Contains(node.Id);

        if (isSelected)
        {
            selectedNodeIds.Remove(node.Id);
        }
        else
        {
            selectedNodeIds.Add(node.Id);
        }

        await CalculateAndUpdateTotals();
        StateHasChanged();
    }

    private bool IsFolderSelected(Node folderNode)
    {
        var children = GetVisualNodesInFolderSequence(folderNode);
        return children.Any(child => child.Type == "vehicle" && selectedNodeIds.Contains(child.Id));
    }

    private RenderFragment RenderFolderNode(Node node) => builder =>
      {
          bool isCurrentlyExpanded = currentlyExpandedFolder?.Id == node.Id;
          bool containsSelected = IsFolderSelected(node);
          var children = GetVisualNodesInFolderSequence(node)
                    .Where(c => c.Type == "vehicle")
                    .ToList();
          int totalChildren = children.Count;
          int selectedChildrenCount = children.Count(c => selectedNodeIds.Contains(c.Id));

          int seq = 0;

          builder.OpenElement(seq++, "div");

          builder.AddAttribute(seq++, "class",
          $"node-content folder-node {(isCurrentlyExpanded ? "folder-active" : "")} {(containsSelected ? "folder-contains-selected" : "")}");
          builder.AddAttribute(seq++, "id", $"node-{node.Id}");
          builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => HandleNodeClick(node)));

          // Иконка
          builder.OpenElement(seq++, "div");
          builder.AddAttribute(seq++, "class", "node-icon");
          builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
          builder.CloseElement();

          // Название
          builder.OpenElement(seq++, "div");
          builder.AddAttribute(seq++, "class", "node-name");
          builder.AddContent(seq++, node.Name);
          builder.CloseElement();

          if (totalChildren > 0)
          {
              builder.OpenElement(seq++, "div");
              builder.AddAttribute(seq++, "class", "folder-child-counter");
              builder.AddContent(seq++, $"{selectedChildrenCount} / {totalChildren}");
              builder.CloseElement();
          }

          // Плюс/минус
          builder.OpenElement(seq++, "div");
          builder.AddAttribute(seq++, "class", "folder-toggle-icon");
          builder.AddContent(seq++, isCurrentlyExpanded ? "−" : "+");
          builder.CloseElement();

          builder.CloseElement();
      };

    private List<Node> GetVisualNodesInFolderSequence(Node folderNode)
    {
        return AllNodesFlat
            .Where(n =>
                n.Rank == folderNode.Rank
                && n.ColumnIndex == folderNode.ColumnIndex
                && n.RowIndex == folderNode.RowIndex
                && n.OrderInFolder.HasValue)
            .OrderBy(n => n.OrderInFolder!.Value)
            .ToList();
    }

    private bool IsRpValueModified(Node node)
    {
        if (!node.RequiredExp.HasValue) return false;

        if (originalRpValues.TryGetValue(node.Id, out var originalValue))
        {
            return node.RequiredExp.Value != originalValue;
        }

        return false;
    }

    private async Task OnRpValueChanged(Node node, ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newValue))
        {
            node.RequiredExp = newValue;
            await CalculateAndUpdateTotals();
            StateHasChanged();
        }
    }

    private RenderFragment RenderVehicleNode(Node node) => __builder =>
     {
         bool isSelected = selectedNodeIds.Contains(node.Id);
         bool isRpModified = IsRpValueModified(node);
         int seq = 0;

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "id", $"node-{node.Id}");

         __builder.AddAttribute(seq++, "class",
         $"node-content vehicle-node {(node.RequiredExp.HasValue ? "rp-editable" : "")} {(isSelected ? "node-selected" : "")}");
         __builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => ToggleNodeSelection(node)));

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-icon");
         __builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
         __builder.CloseElement();

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-info");

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-name");
         __builder.AddContent(seq++, node.Name);
         __builder.CloseElement();

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-details");

         if (node.Br.HasValue)
         {
             __builder.OpenElement(seq++, "div");
             __builder.AddAttribute(seq++, "class", "node-detail-item node-br");
             __builder.AddContent(seq++, $"БР: {node.Br}");
             __builder.CloseElement();
         }

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-detail-item node-exp");
         if (node.RequiredExp.HasValue)
         {
             __builder.AddContent(seq++, "ОИ: ");
             __builder.OpenElement(seq++, "input");
             __builder.AddAttribute(seq++, "type", "number");
             __builder.AddAttribute(seq++, "class", $"rp-input {(isRpModified ? "rp-modified" : "")}");
             __builder.AddAttribute(seq++, "min", "0");
             __builder.AddAttribute(seq++, "value", BindConverter.FormatValue(node.RequiredExp));
             __builder.AddAttribute(seq++, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(this,
                 e => OnRpValueChanged(node, e)));
             __builder.AddAttribute(seq++, "onclick", "event.stopPropagation();");
             __builder.AddElementReferenceCapture(seq++, capturedRef => { });
             __builder.CloseElement();
         }
         __builder.CloseElement();

         __builder.CloseElement();

         __builder.CloseElement();

         __builder.CloseElement();
     };

    private async Task DrawConnectionLines()
    {
        if (JSRuntime == null || Dependencies == null || !Dependencies.Any()) return;
        try
        {
            var connectionData = Dependencies.Select(dep => new
            {
                lineId = $"dep-{dep.NodeId}-{dep.PrerequisiteNodeId}",
                sourceElementId = $"node-{dep.PrerequisiteNodeId}",
                targetElementId = $"node-{dep.NodeId}"
            }).ToList();
            await JSRuntime.InvokeVoidAsync("techTreeFunctions.drawConnections", connectionData);
        }
        catch
        {
        }
    }
}