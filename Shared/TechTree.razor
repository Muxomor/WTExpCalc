@using WTExpCalc.Models
@using WTExpCalc.Services
@inject IExperienceApi Api
@inject IJSRuntime JSRuntime

<div class="tech-tree-container @LoadingState" id="tech-tree-container-id">
    @if (GridNodes.Any())
    {
        <div class="tree-grid" style="@GridStyles">
            @{
                var cumulativeRowsBefore = new Dictionary<int, int>();
                if (MaxRank > 0 && MaxRowIndexPerRank != null)
                {
                    int currentCumulativeRowCount = 0;
                    for (int r = 1; r <= MaxRank; r++)
                    {
                        cumulativeRowsBefore[r] = currentCumulativeRowCount;
                        int rowsInRankR = (MaxRowIndexPerRank.TryGetValue(r, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        currentCumulativeRowCount += rowsInRankR;
                    }
                }

                if (cumulativeRowsBefore != null)
                {
                    @foreach (var rank in Enumerable.Range(1, MaxRank))
                    {
                        int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        int startGridRow = 2 + (cumulativeRowsBefore.TryGetValue(rank, out var cumRows) ? cumRows : 0);
                        string rankLabelStyle = $"grid-column: 1; grid-row: {startGridRow} / span {rowsInThisRank};";
    var requirement = rankRequirements.FirstOrDefault(r => r.PreviousRank == rank);
    int requiredCount = requirement?.RequiredUnits ?? 0; // Получаем Y
    // Считаем количество ВЫДЕЛЕННОЙ техники НА ЭТОМ ранге
    int selectedCount = AllNodesFlat.Count(n => n.Rank == rank && n.Type == "vehicle" && selectedNodeIds.Contains(n.Id)); // Получаем X

    <div class="rank-label" style="@rankLabelStyle">
        <span>Rank @rank</span>
        @* Отображаем счетчик, если требование найдено *@
        @if (requirement != null)
        {
            <span class="rank-requirement-counter @(selectedCount >= requiredCount ? "req-met" : "req-not-met")">
                @selectedCount / @requiredCount
            </span>
        }
    </div>
                    }
                }
            }

            @foreach (var node in GridNodes)
            {
                <div @key="node.Id" class="@GetNodeCssClass(node)" style="@GetNodeGridStyle(node)" id="node-container-@node.Id">
                    @if (node.Type == "folder")
                    {
                        @RenderFolderNode(node)
                    }
                    else
                    {
                        @RenderVehicleNode(node)
                    }
                </div>
            }

            <svg class="tree-connections-overlay" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 0;">
                @if (Dependencies != null)
                {
                    @foreach (var dep in Dependencies)
                    {
                        <line id="dep-@dep.NodeId-@dep.PrerequisiteNodeId"
                              x1="0" y1="0" x2="0" y2="0"
                              stroke="#cccccc" stroke-width="2"
                              marker-end="url(#arrowhead)"
                              visibility="hidden" />
                    }
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                                refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#cccccc" />
                        </marker>
                    </defs>
                }
            </svg>
            @{
                // Вычисляем последнюю колонку стандартной техники
                var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
                int maxStdColIndex = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
                int standardColumnCount = Math.Max(0, maxStdColIndex + 1);
                int premiumDividerColumn = 2 + standardColumnCount; // +1 за RankLabel, +1 за сам индекс -> +1 за следующую колонку

                // Вычисляем последнюю строку сетки данных
                int lastDataRow = 1 + TotalDataGridRows; // +1, т.к. строки начинаются с 1 в CSS Grid

                // --- Вертикальный разделитель (Премиум) ---
                // Проверяем, есть ли вообще премиум техника
                var premiumNodesExist = AllNodesFlat.Any(n => n.TechCategory != "standard");
                if (premiumNodesExist && standardColumnCount > 0) // Рисуем, только если есть и стандартные, и премиум
                {
                    string premiumDividerStyle = $"grid-column: {premiumDividerColumn}; grid-row: 2 / {lastDataRow + 1};"; // Начинаем со 2-й строки до конца
                    <div class="premium-divider-v" style="@premiumDividerStyle"></div>
                }

                // --- Горизонтальные разделители (Ранги) ---
                for (int rank = 1; rank < MaxRank; rank++) // До предпоследнего ранга
                {
                    // Находим последнюю строку текущего ранга
                    int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIdx) ? maxRowIdx : 0) + 1;
                    int startGridRowCurrentRank = 2 + (cumulativeRowsBefore.TryGetValue(rank, out var cumRows) ? cumRows : 0);
                    int endGridRowCurrentRank = startGridRowCurrentRank + rowsInThisRank - 1;

                    // Стиль для разделителя ПОД текущим рангом
                    string rankDividerStyle = $"grid-column: 2 / -1; grid-row: {endGridRowCurrentRank + 1};"; // +1 чтобы линия была ПОД последней строкой ранга

                    <div class="rank-divider-h" style="@rankDividerStyle"></div>
                }
            }

        </div>
        @if (currentlyExpandedFolder != null)
        {
            // Используем @key, чтобы Blazor пересоздавал попап при смене папки
            <div class="folder-popup" id="folder-popup-@currentlyExpandedFolder.Id" style="position:absolute; visibility: hidden;" @key="currentlyExpandedFolder.Id">
                @* Здесь можно добавить стрелку, если нужно *@
                @* <div class="folder-popup-arrow"></div> *@
                <div class="folder-popup-content">
                    @foreach (var child in GetVisualNodesInFolderSequence(currentlyExpandedFolder))
                    {
                        // Важно: рендерим только дочерние машины, а не другие папки
                        if (child.Type == "vehicle")
                        {
                            // Используем тот же рендерер, что и в сетке
                            // Оборачиваем в div, чтобы применить стили, если нужно
                            <div class="folder-popup-item">
                                @RenderVehicleNode(child)
                            </div>
                        }
                    }
                </div>
            </div>
        }
    }
    else if (LoadingState != "loading")
    {
        <p>Нет данных для отображения для NationId=@NationId, TypeId=@TypeId.</p>
    }

    @if (LoadingState == "loading")
    {
        <p>Загрузка...</p>
    }
    @if (LoadingState == "error")
    {
        <p style="color: red;">Ошибка загрузки данных!</p>
    }
</div>

@code {
    [Parameter] public int NationId { get; set; }
    [Parameter] public int TypeId { get; set; }
    [Parameter] public EventCallback<TotalsUpdateEventArgs> OnTotalsUpdated { get; set; }

    private List<Node> AllNodesFlat = new();
    private Dictionary<int, Node> NodeLookup = new();
    private List<Node> GridNodes = new();
    private List<NodeDependency> Dependencies = new();
    // private HashSet<int> ExpandedFolderIds = new(); // <-- ЗАМЕНИТЬ
    private Node? currentlyExpandedFolder; // <-- НА ЭТО (хранит ссылку на узел или null)
    private string LoadingState = "loading";
    private List<RankRequirement> rankRequirements = new(); // Для хранения требований по рангам
    private HashSet<int> selectedNodeIds = new();
    private int MaxRank = 0;
    private string GridStyles = "";
    // private Dictionary<(int Rank, int Col, string Category), List<Node>> _vehiclesInFoldersCache = new(); // Эта логика может измениться
    private Dictionary<int, int> MaxRowIndexPerRank = new();
    private int TotalDataGridRows = 0; 
    private long totalSelectedRp = 0;
    private long totalSelectedSl = 0; private int _previousNationId = -1; // Инициализируем невалидным значением
    private int _previousTypeId = -1;   // Инициализируем невалидным значением
    private bool _isFirstLoad = true;

    public class TotalsUpdateEventArgs : EventArgs
    {
        public long TotalRp { get; set; } 
        public long TotalSl { get; set; }
    }



    protected override async Task OnParametersSetAsync()
    {
        // Вызываем LoadData только если параметры изменились ИЛИ это первая загрузка
        if (_isFirstLoad || NationId != _previousNationId || TypeId != _previousTypeId)
        {
            Console.WriteLine($"[DEBUG] OnParametersSetAsync: Parameters changed or first load. Loading data for NationId={NationId}, TypeId={TypeId}");

            // Сохраняем текущие значения как "предыдущие" для следующей проверки
            _previousNationId = NationId;
            _previousTypeId = TypeId;
            _isFirstLoad = false; // Сбрасываем флаг первой загрузки

            await LoadData(); // <--- ВЫЗЫВАЕМ LoadData ЗДЕСЬ
        }
        else
        {
            Console.WriteLine($"[DEBUG] OnParametersSetAsync: Parameters NOT changed. Skipping LoadData.");
        }
    }

    private async Task LoadData()
    {
        Console.WriteLine($"[DEBUG] LoadData START for NationId={NationId}, TypeId={TypeId}");

        try
        {
            LoadingState = "loading";
            // Очищаем все перед загрузкой
            MaxRowIndexPerRank.Clear();
            // _vehiclesInFoldersCache.Clear(); // Если используется, раскомментировать
            GridNodes.Clear();
            Dependencies.Clear();
            rankRequirements.Clear(); // Очищаем требования
            selectedNodeIds.Clear();  // Очищаем выделение
            currentlyExpandedFolder = null; // Закрываем папку
            StateHasChanged(); // Обновляем UI (показываем загрузку)

            // Загружаем основные данные
            AllNodesFlat = await Api.GetAllNodesFlatAsync(NationId, TypeId);
            if (AllNodesFlat == null || !AllNodesFlat.Any())
            {
                // Обработка случая без данных (как было)
                MaxRank = 0;
                GridStyles = "";
                LoadingState = "loaded";
                StateHasChanged();
                return;
            }

            // Загружаем требования по рангам
            rankRequirements = await Api.GetRankRequirementsAsync(NationId, TypeId);

            // Остальная логика загрузки и подготовки (как было)
            NodeLookup = AllNodesFlat.ToDictionary(n => n.Id);
            BuildHierarchy();
            PrepareGridNodesAndCalculateRows();
            Dependencies = await Api.GetAllDependenciesAsync(NationId, TypeId);
            CalculateGridDimensions();
            LoadingState = "loaded";
            await CalculateAndUpdateTotals();
        }
        catch (Exception ex)
        {
            // ... (обработка ошибок) ...
            // Сброс сумм при ошибке и вызов события
            totalSelectedRp = 0;
            totalSelectedSl = 0;
            if (OnTotalsUpdated.HasDelegate)
            {
                await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs { TotalRp = 0, TotalSl = 0 });
            }
        }
        StateHasChanged(); // Оставляем здесь на случай, если LoadData вызывается не только из OnParametersSetAsync
        Console.WriteLine($"[DEBUG] LoadData END for NationId={NationId}, TypeId={TypeId}");

    }

    private async Task CalculateAndUpdateTotals()
    {
        Console.WriteLine($"[DEBUG] CalculateAndUpdateTotals called. Selected IDs count: {selectedNodeIds.Count}"); // <-- ДОБАВИТЬ

        totalSelectedRp = 0;
        totalSelectedSl = 0;

        foreach (int nodeId in selectedNodeIds)
        {
            if (NodeLookup.TryGetValue(nodeId, out var node))
            {
                long rpValue = node.RequiredExp ?? 0; // Используем текущее значение RP
                long slValue = node.SilverCost ?? 0; // Используем SL
                totalSelectedRp += rpValue;
                totalSelectedSl += slValue;
                // Выводим, что суммируем (для отладки данных)
                Console.WriteLine($"[DEBUG]   - Node ID: {nodeId}, RP: {rpValue}, SL: {slValue}. Current totals: RP={totalSelectedRp}, SL={totalSelectedSl}"); // <-- ДОБАВИТЬ
            }
            else
            {
                Console.WriteLine($"[DEBUG]   - Node ID: {nodeId} NOT FOUND in NodeLookup!"); // <-- ДОБАВИТЬ (на случай ошибки)
            }
        }
        Console.WriteLine($"[DEBUG] Final calculated totals: RP={totalSelectedRp}, SL={totalSelectedSl}");

        // Вызываем событие ТОЛЬКО если есть подписчик
        if (OnTotalsUpdated.HasDelegate)
        {
            Console.WriteLine("[DEBUG] OnTotalsUpdated has delegate. Invoking...");
            await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs { TotalRp = totalSelectedRp, TotalSl = totalSelectedSl });
            Console.WriteLine("[DEBUG] OnTotalsUpdated invoked successfully.");
        }
        else
        {
            Console.WriteLine("[DEBUG] WARNING: OnTotalsUpdated delegate is NOT set in CalculateAndUpdateTotals!"); // Изменили на Warning
        }
    }

    private void BuildHierarchy()
    {
        if (NodeLookup == null || !NodeLookup.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            node.Children.Clear();
            node.ParentNode = null;
            if (node.ParentId.HasValue && NodeLookup.TryGetValue(node.ParentId.Value, out var parent))
            {
                node.ParentNode = parent;
                parent.Children.Add(node);
            }
        }
    }

    private void PrepareGridNodesAndCalculateRows()
    {
        GridNodes.Clear();
        MaxRowIndexPerRank.Clear();
        TotalDataGridRows = 0;

        if (AllNodesFlat == null || !AllNodesFlat.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            int currentMax = MaxRowIndexPerRank.TryGetValue(node.Rank, out var max) ? max : -1;
            if ((node.RowIndex ?? 0) > currentMax) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
            else if (!MaxRowIndexPerRank.ContainsKey(node.Rank)) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
        }
        TotalDataGridRows = MaxRowIndexPerRank.Sum(kvp => kvp.Value + 1);

        foreach (var node in AllNodesFlat)
        {
            bool isGridNode;
            if (node.ParentNode == null) isGridNode = true;
            else if (node.ParentNode.Type != "folder") isGridNode = true;
            else
            {
                if (node.Rank != node.ParentNode.Rank ||
                    (node.ColumnIndex ?? 0) != (node.ParentNode.ColumnIndex ?? 0) ||
                    (node.RowIndex ?? 0) != (node.ParentNode.RowIndex ?? 0))
                    isGridNode = true;
                else
                    isGridNode = false;
            }
            if (isGridNode) GridNodes.Add(node);
        }
    }

    private void CalculateGridDimensions()
    {
        MaxRank = AllNodesFlat.Any() ? AllNodesFlat.Max(n => n.Rank) : 0;
        var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
        int maxStd = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        var premiumNodes = AllNodesFlat.Where(n => n.TechCategory != "standard");
        int maxPrem = premiumNodes.Any() ? premiumNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        int stdCount = Math.Max(0, maxStd + 1);
        int premCount = Math.Max(0, maxPrem + 1);

        string gridRowsStyle = "auto";
        if (TotalDataGridRows > 0)
            gridRowsStyle += $" repeat({TotalDataGridRows}, minmax(80px, auto))";
        else if (MaxRank > 0)
            gridRowsStyle += $" repeat({MaxRank}, minmax(80px, auto))";

        GridStyles =
            $"display: grid; " +
            $"grid-template-rows: {gridRowsStyle}; " +
            $"grid-template-columns: auto {(stdCount > 0 ? $"repeat({stdCount}, minmax(100px, auto)) " : "")}{(premCount > 0 ? $"repeat({premCount}, minmax(100px, auto))" : "")}; " +
            $"gap: 15px 25px; position: relative;";
    }

    private string GetNodeGridStyle(Node node)
    {
        int col = node.TechCategory == "standard"
            ? 1 + (node.ColumnIndex ?? 0) + 1
            : 1 + ((AllNodesFlat.Where(n => n.TechCategory == "standard").Max(n => n.ColumnIndex ?? 0)) + 1) + (node.ColumnIndex ?? 0) + 1;
        int calculatedRow = 1;
        for (int r = 1; r < node.Rank; r++)
            calculatedRow += (MaxRowIndexPerRank.TryGetValue(r, out var prev) ? prev : 0) + 1;
        calculatedRow += (node.RowIndex ?? 0);
        return $"grid-column: {col}; grid-row: {calculatedRow + 1}; z-index:1; position:relative;";
    }

    private string GetNodeCssClass(Node node)
    {
        // Убираем добавление класса folder-open отсюда
        return $"tree-grid-item node-type-{node.Type} tech-cat-{node.TechCategory}";
    }

    private async Task HandleNodeClick(Node node) // Делаем async для вызова JS
    {
        if (node.Type != "folder") return;

        // Если кликнули по уже открытой папке - закрываем
        if (currentlyExpandedFolder?.Id == node.Id)
        {
            currentlyExpandedFolder = null;
        }
        else // Иначе - открываем новую (старая закроется автоматически)
        {
            currentlyExpandedFolder = node;
        }

        StateHasChanged(); // Обновляем DOM (попап появится/исчезнет)

        // Если папка открыта, позиционируем попап через JS
        if (currentlyExpandedFolder != null)
        {
            // Небольшая задержка, чтобы Blazor успел отрендерить попап в DOM
            await Task.Delay(10);
            try
            {
                // Вызываем JS для установки top/left
                await JSRuntime.InvokeVoidAsync("techTreeFunctions.positionFolderPopup",
                    $"folder-popup-{currentlyExpandedFolder.Id}", // ID попапа
                    $"node-{currentlyExpandedFolder.Id}",         // ID заголовка папки (цель)
                    "tech-tree-container-id"                     // ID контейнера дерева (для расчета смещения)
                );
            }
            catch (Exception ex) { Console.WriteLine($"JS interop error: {ex.Message}"); }
        }
        // Перерисовка линий теперь может быть не нужна сразу после клика, т.к. структура не меняется
        // await DrawConnectionLines();
    }

    private async Task ToggleNodeSelection(Node node) // Убедимся, что он async, так как вызывает async метод
    {
        if (node.Type != "vehicle") return;

        Console.WriteLine($"[DEBUG] ToggleNodeSelection called for Node ID: {node.Id}, Name: {node.Name}"); // <-- ДОБАВИТЬ

        bool isSelected = selectedNodeIds.Contains(node.Id);
        int initialCount = selectedNodeIds.Count; // <-- ДОБАВИТЬ

        if (isSelected)
        {
            selectedNodeIds.Remove(node.Id);
            Console.WriteLine($"[DEBUG] Node {node.Id} REMOVED from selection."); // <-- ДОБАВИТЬ
        }
        else
        {
            selectedNodeIds.Add(node.Id);
            Console.WriteLine($"[DEBUG] Node {node.Id} ADDED to selection."); // <-- ДОБАВИТЬ
        }

        Console.WriteLine($"[DEBUG] Selection count changed from {initialCount} to {selectedNodeIds.Count}."); // <-- ДОБАВИТЬ

        // Пересчитываем суммы и вызываем событие
        await CalculateAndUpdateTotals(); // Убедитесь, что этот вызов есть

        StateHasChanged(); // Убедитесь, что этот вызов есть
        Console.WriteLine($"[DEBUG] ToggleNodeSelection finished for Node ID: {node.Id}. StateHasChanged called."); // <-- ДОБАВИТЬ
    }

    private bool IsFolderSelected(Node folderNode)
    {
        // Папка считается "выделенной", если хотя бы один дочерний узел техники выделен
        // Используем NodeLookup для быстрого поиска детей по ID, если иерархия построена
        // или GetVisualNodesInFolderSequence, если он возвращает всех нужных детей

        // Вариант 1: Если у Node есть Children
        // return folderNode.Children.Any(child => child.Type == "vehicle" && selectedNodeIds.Contains(child.Id));

        // Вариант 2: Используем GetVisualNodesInFolderSequence (если он надежно возвращает всех детей)
        var children = GetVisualNodesInFolderSequence(folderNode);
        return children.Any(child => child.Type == "vehicle" && selectedNodeIds.Contains(child.Id));

        // Вариант 3: Ищем по ParentId (если иерархия не всегда полная в Children)
        // return AllNodesFlat.Any(n => n.ParentId == folderNode.Id && n.Type == "vehicle" && selectedNodeIds.Contains(n.Id));
    }

    private RenderFragment RenderFolderNode(Node node) => builder =>
      {
      bool isCurrentlyExpanded = currentlyExpandedFolder?.Id == node.Id;
      bool containsSelected = IsFolderSelected(node); // Проверяем наличие выделенных детей
      int seq = 0;

      // Внешний контейнер .folder-visual-container БОЛЬШЕ НЕ НУЖЕН И НЕ РЕНДЕРИТСЯ

      // Рендерим ТОЛЬКО сам «заголовок» папки
      builder.OpenElement(seq++, "div"); // Открываем div заголовка

      // Добавляем нужные классы ПРЯМО СЮДА
      builder.AddAttribute(seq++, "class",
          $"node-content folder-node {(isCurrentlyExpanded ? "folder-active" : "")} {(containsSelected ? "folder-contains-selected" : "")}");
      builder.AddAttribute(seq++, "id", $"node-{node.Id}"); // ID для JS и стилей
      builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => HandleNodeClick(node))); // Обработчик клика

      // Иконка
      builder.OpenElement(seq++, "div");
      builder.AddAttribute(seq++, "class", "node-icon");
      builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
      builder.CloseElement(); // Закрыли иконку

      // Название
      builder.OpenElement(seq++, "div");
      builder.AddAttribute(seq++, "class", "node-name");
      builder.AddContent(seq++, node.Name);
      builder.CloseElement(); // Закрыли название

      // Плюс/минус
      builder.OpenElement(seq++, "div");
      builder.AddAttribute(seq++, "class", "folder-toggle-icon");
      builder.AddContent(seq++, isCurrentlyExpanded ? "−" : "+");
      builder.CloseElement(); // Закрыли плюс/минус

      builder.CloseElement(); // Закрыли div заголовка ("node-content folder-node")
      };

    private List<Node> GetVisualNodesInFolderSequence(Node folderNode)
    {
        // Берём из полного списка все узлы, у которых указан order_in_folder
        // и которые лежат в той же «ячейке» (rank, column, row)
        return AllNodesFlat
            .Where(n =>
                n.Rank == folderNode.Rank
                && n.ColumnIndex == folderNode.ColumnIndex
                && n.RowIndex == folderNode.RowIndex
                && n.OrderInFolder.HasValue)
            .OrderBy(n => n.OrderInFolder!.Value)
            .ToList();
    }

    private RenderFragment RenderVehicleNode(Node node) => __builder =>
     {
     bool isSelected = selectedNodeIds.Contains(node.Id);
     int seq = 0;

     // --- Open the MAIN vehicle node element ---
     __builder.OpenElement(seq++, "div");
     __builder.AddAttribute(seq++, "id", $"node-{node.Id}"); // ID for targeting

     // Add ALL classes and the onclick handler HERE
     __builder.AddAttribute(seq++, "class",
         $"node-content vehicle-node {(node.RequiredExp.HasValue ? "rp-editable" : "")} {(isSelected ? "node-selected" : "")}");
     __builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => ToggleNodeSelection(node)));

     // --- Icon ---
     __builder.OpenElement(seq++, "div");
     __builder.AddAttribute(seq++, "class", "node-icon");
     __builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
     __builder.CloseElement(); // Close Icon

     // --- Info ---
     __builder.OpenElement(seq++, "div");
     __builder.AddAttribute(seq++, "class", "node-info");

     // --- Name ---
     __builder.OpenElement(seq++, "div");
     __builder.AddAttribute(seq++, "class", "node-name");
     __builder.AddContent(seq++, node.Name);
     __builder.CloseElement(); // Close Name

     // --- Details ---
     __builder.OpenElement(seq++, "div");
     __builder.AddAttribute(seq++, "class", "node-details");

     // BR
     if (node.Br.HasValue)
     {
         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-detail-item node-br");
         __builder.AddContent(seq++, $"BR: {node.Br}");
         __builder.CloseElement(); // Close BR Div
     }

     // RP
     __builder.OpenElement(seq++, "div");
     __builder.AddAttribute(seq++, "class", "node-detail-item node-exp");
     if (node.RequiredExp.HasValue)
     {
         __builder.AddContent(seq++, "RP: ");
         __builder.OpenElement(seq++, "input");
         __builder.AddAttribute(seq++, "type", "number");
         __builder.AddAttribute(seq++, "class", "rp-input");
         __builder.AddAttribute(seq++, "min", "0");
         // --- TYPE CHECK --- Make sure the binder type matches node.RequiredExp's type (int? or long?)
         __builder.AddAttribute(seq++, "value", BindConverter.FormatValue(node.RequiredExp)); // Use nullable directly
         __builder.AddAttribute(seq++, "onchange", EventCallback.Factory.CreateBinder<int?>(this, // <-- CHANGE int? to long? if needed
             v => { node.RequiredExp = v; StateHasChanged(); /* Optional: Add StateHasChanged if needed */ }, node.RequiredExp));
         __builder.AddElementReferenceCapture(seq++, capturedRef => { /* ... */ });
         __builder.CloseElement(); // Close Input
     }
     __builder.CloseElement(); // Close RP Div

     __builder.CloseElement(); // Close Details

     __builder.CloseElement(); // Close Info

     // --- Close the MAIN vehicle node element ---
     __builder.CloseElement();
     };

    private async Task DrawConnectionLines()
    {
        if (JSRuntime == null || Dependencies == null || !Dependencies.Any()) return;
        try
        {
            var connectionData = Dependencies.Select(dep => new
            {
                lineId = $"dep-{dep.NodeId}-{dep.PrerequisiteNodeId}",
                sourceElementId = $"node-{dep.PrerequisiteNodeId}",
                targetElementId = $"node-{dep.NodeId}"
            }).ToList();
            await JSRuntime.InvokeVoidAsync("techTreeFunctions.drawConnections", connectionData);
        }
        catch
        {
            // Handle JS interop errors silently
        }
    }
}
