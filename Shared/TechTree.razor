@using WTExpCalc.Models
@using WTExpCalc.Services
@inject IExperienceApi Api
@inject IJSRuntime JSRuntime

<div class="tech-tree-container @LoadingState">
    @if (GridNodes.Any())
    {
        <div class="tree-grid" style="@GridStyles">
            @{
                var cumulativeRowsBefore = new Dictionary<int, int>();
                if (MaxRank > 0 && MaxRowIndexPerRank != null)
                {
                    int currentCumulativeRowCount = 0;
                    for (int r = 1; r <= MaxRank; r++)
                    {
                        cumulativeRowsBefore[r] = currentCumulativeRowCount;
                        int rowsInRankR = (MaxRowIndexPerRank.TryGetValue(r, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        currentCumulativeRowCount += rowsInRankR;
                    }
                }

                if (cumulativeRowsBefore != null)
                {
                    @foreach (var rank in Enumerable.Range(1, MaxRank))
                    {
                        int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        int startGridRow = 2 + (cumulativeRowsBefore.TryGetValue(rank, out var cumRows) ? cumRows : 0);
                        string rankLabelStyle = $"grid-column: 1; grid-row: {startGridRow} / span {rowsInThisRank};";

                        <div class="rank-label" style="@rankLabelStyle">
                            <span>Rank @rank</span>
                        </div>
                    }
                }
            }

            @foreach (var node in GridNodes)
            {
                <div @key="node.Id" class="@GetNodeCssClass(node)" style="@GetNodeGridStyle(node)" id="node-container-@node.Id">
                    @if (node.Type == "folder")
                    {
                        @RenderFolderNode(node)
                    }
                    else
                    {
                        @RenderVehicleNode(node)
                    }
                </div>
            }

            <svg class="tree-connections-overlay" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 0;">
                @if (Dependencies != null)
                {
                    @foreach (var dep in Dependencies)
                    {
                        <line id="dep-@dep.NodeId-@dep.PrerequisiteNodeId"
                              x1="0" y1="0" x2="0" y2="0"
                              stroke="#cccccc" stroke-width="2"
                              marker-end="url(#arrowhead)"
                              visibility="hidden" />
                    }
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                                refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#cccccc" />
                        </marker>
                    </defs>
                }
            </svg>
        </div>
    }
    else if (LoadingState != "loading")
    {
        <p>Нет данных для отображения для NationId=@NationId, TypeId=@TypeId.</p>
    }

    @if (LoadingState == "loading")
    {
        <p>Загрузка...</p>
    }
    @if (LoadingState == "error")
    {
        <p style="color: red;">Ошибка загрузки данных!</p>
    }
</div>

@code {
    [Parameter] public int NationId { get; set; }
    [Parameter] public int TypeId { get; set; }

    private List<Node> AllNodesFlat = new();
    private Dictionary<int, Node> NodeLookup = new();
    private List<Node> GridNodes = new();
    private List<NodeDependency> Dependencies = new();
    private HashSet<int> ExpandedFolderIds = new();
    private string LoadingState = "loading";

    private int MaxRank = 0;
    private string GridStyles = "";
    private Dictionary<(int Rank, int Col, string Category), List<Node>> _vehiclesInFoldersCache = new();
    private Dictionary<int, int> MaxRowIndexPerRank = new();
    private int TotalDataGridRows = 0;

    protected override async Task OnParametersSetAsync()
    {
        await LoadData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (LoadingState == "loaded" && Dependencies.Any())
        {
            await Task.Delay(50);
            await DrawConnectionLines();
        }
    }

    private async Task LoadData()
    {
        try
        {
            LoadingState = "loading";
            MaxRowIndexPerRank.Clear();
            _vehiclesInFoldersCache.Clear();
            GridNodes.Clear();
            Dependencies.Clear();
            StateHasChanged();

            AllNodesFlat = await Api.GetAllNodesFlatAsync(NationId, TypeId);
            if (AllNodesFlat == null || !AllNodesFlat.Any())
            {
                MaxRank = 0;
                GridStyles = "";
                LoadingState = "loaded";
                StateHasChanged();
                return;
            }

            NodeLookup = AllNodesFlat.ToDictionary(n => n.Id);
            BuildHierarchy();
            PrepareGridNodesAndCalculateRows();
            Dependencies = await Api.GetAllDependenciesAsync(NationId, TypeId);
            CalculateGridDimensions();
            LoadingState = "loaded";
        }
        catch (Exception ex)
        {
            LoadingState = "error";
            Console.WriteLine($"Error loading tech tree data: {ex.Message}");
        }
        StateHasChanged();
    }

    private void BuildHierarchy()
    {
        if (NodeLookup == null || !NodeLookup.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            node.Children.Clear();
            node.ParentNode = null;
            if (node.ParentId.HasValue && NodeLookup.TryGetValue(node.ParentId.Value, out var parent))
            {
                node.ParentNode = parent;
                parent.Children.Add(node);
            }
        }
    }

    private void PrepareGridNodesAndCalculateRows()
    {
        GridNodes.Clear();
        MaxRowIndexPerRank.Clear();
        TotalDataGridRows = 0;

        if (AllNodesFlat == null || !AllNodesFlat.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            int currentMax = MaxRowIndexPerRank.TryGetValue(node.Rank, out var max) ? max : -1;
            if ((node.RowIndex ?? 0) > currentMax) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
            else if (!MaxRowIndexPerRank.ContainsKey(node.Rank)) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
        }
        TotalDataGridRows = MaxRowIndexPerRank.Sum(kvp => kvp.Value + 1);

        foreach (var node in AllNodesFlat)
        {
            bool isGridNode;
            if (node.ParentNode == null) isGridNode = true;
            else if (node.ParentNode.Type != "folder") isGridNode = true;
            else
            {
                if (node.Rank != node.ParentNode.Rank ||
                    (node.ColumnIndex ?? 0) != (node.ParentNode.ColumnIndex ?? 0) ||
                    (node.RowIndex ?? 0) != (node.ParentNode.RowIndex ?? 0))
                    isGridNode = true;
                else
                    isGridNode = false;
            }
            if (isGridNode) GridNodes.Add(node);
        }
    }

    private void CalculateGridDimensions()
    {
        MaxRank = AllNodesFlat.Any() ? AllNodesFlat.Max(n => n.Rank) : 0;
        var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
        int maxStd = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        var premiumNodes = AllNodesFlat.Where(n => n.TechCategory != "standard");
        int maxPrem = premiumNodes.Any() ? premiumNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        int stdCount = Math.Max(0, maxStd + 1);
        int premCount = Math.Max(0, maxPrem + 1);

        string gridRowsStyle = "auto";
        if (TotalDataGridRows > 0)
            gridRowsStyle += $" repeat({TotalDataGridRows}, minmax(80px, auto))";
        else if (MaxRank > 0)
            gridRowsStyle += $" repeat({MaxRank}, minmax(80px, auto))";

        GridStyles =
            $"display: grid; " +
            $"grid-template-rows: {gridRowsStyle}; " +
            $"grid-template-columns: auto {(stdCount > 0 ? $"repeat({stdCount}, minmax(100px, auto)) " : "")}{(premCount > 0 ? $"repeat({premCount}, minmax(100px, auto))" : "")}; " +
            $"gap: 15px 25px; position: relative;";
    }

    private string GetNodeGridStyle(Node node)
    {
        int col = node.TechCategory == "standard"
            ? 1 + (node.ColumnIndex ?? 0) + 1
            : 1 + ((AllNodesFlat.Where(n => n.TechCategory == "standard").Max(n => n.ColumnIndex ?? 0)) + 1) + (node.ColumnIndex ?? 0) + 1;
        int calculatedRow = 1;
        for (int r = 1; r < node.Rank; r++)
            calculatedRow += (MaxRowIndexPerRank.TryGetValue(r, out var prev) ? prev : 0) + 1;
        calculatedRow += (node.RowIndex ?? 0);
        return $"grid-column: {col}; grid-row: {calculatedRow + 1}; z-index:1; position:relative;";
    }

    private string GetNodeCssClass(Node node)
        => $"tree-grid-item node-type-{node.Type} tech-cat-{node.TechCategory}";

    private void HandleNodeClick(Node node)
    {
        if (node.Type != "folder") return;
        if (ExpandedFolderIds.Contains(node.Id)) ExpandedFolderIds.Remove(node.Id);
        else ExpandedFolderIds.Add(node.Id);
        StateHasChanged();
        Task.Delay(50).ContinueWith(async _ => await DrawConnectionLines());
    }

    private RenderFragment RenderFolderNode(Node node) => __builder =>
    {
        bool isExpanded = ExpandedFolderIds.Contains(node.Id);
        string containerClass = "folder-visual-container";
        string folderNodeClasses = $"node-content folder-node {(isExpanded ? "folder-expanded" : "folder-collapsed")}";

        __builder.OpenElement(0, "div");
        __builder.AddAttribute(1, "class", containerClass);
        __builder.OpenElement(2, "div");
        __builder.AddAttribute(3, "class", folderNodeClasses);
        __builder.AddAttribute(4, "id", $"node-{node.Id}");
        __builder.AddAttribute(5, "onclick", EventCallback.Factory.Create(this, () => HandleNodeClick(node)));
        __builder.OpenElement(6, "div"); __builder.AddAttribute(7, "class", "node-icon"); __builder.AddAttribute(8, "style", $"background-image:url('{node.ImageUrl}')"); __builder.CloseElement();
        __builder.OpenElement(9, "div"); __builder.AddAttribute(10, "class", "node-name"); __builder.AddContent(11, node.Name); __builder.CloseElement();
        __builder.OpenElement(12, "div"); __builder.AddAttribute(13, "class", "folder-toggle-icon"); __builder.AddContent(14, isExpanded ? "-" : "+"); __builder.CloseElement();
        __builder.CloseElement();

        if (isExpanded)
        {
            var children = GetVisualNodesInFolderSequence(node);
            if (children.Any())
            {
                __builder.OpenElement(15, "div"); __builder.AddAttribute(16, "class", "folder-items-container");
                foreach (var child in children)
                {
                    if (child.Type == "vehicle") __builder.AddContent(17, RenderVehicleNode(child));
                }
                __builder.CloseElement();
            }
        }
        __builder.CloseElement();
    };

    private List<Node> GetVisualNodesInFolderSequence(Node folderNode)
    {
        var results = new List<Node>();
        var queue = new Queue<Node>(folderNode.Children
            .Where(c => c.Rank == folderNode.Rank && (c.ColumnIndex ?? 0) == (folderNode.ColumnIndex ?? 0) && (c.RowIndex ?? 0) == (folderNode.RowIndex ?? 0))
            .OrderBy(c => c.OrderInFolder ?? int.MaxValue));
        var visited = new HashSet<int> { folderNode.Id };
        while (queue.Any())
        {
            var current = queue.Dequeue();
            if (!visited.Add(current.Id)) continue;
            if (current.Rank == folderNode.Rank && (current.ColumnIndex ?? 0) == (folderNode.ColumnIndex ?? 0) && (current.RowIndex ?? 0) == (folderNode.RowIndex ?? 0))
            {
                results.Add(current);
                foreach (var child in current.Children.OrderBy(c => c.OrderInFolder ?? int.MaxValue).ThenBy(c => c.RowIndex ?? 0))
                    if (!visited.Contains(child.Id)) queue.Enqueue(child);
            }
        }
        return results.OrderBy(n => n.OrderInFolder ?? int.MaxValue).ThenBy(n => n.RowIndex ?? 0).ToList();
    }

    private RenderFragment RenderVehicleNode(Node node) => __builder =>
    {
        __builder.OpenElement(0, "div"); __builder.AddAttribute(1, "id", $"node-{node.Id}"); __builder.AddAttribute(2, "class", "node-content vehicle-node");
        __builder.OpenElement(3, "div"); __builder.AddAttribute(4, "class", "node-icon"); __builder.AddAttribute(5, "style", $"background-image:url('{node.ImageUrl}')"); __builder.CloseElement();
        __builder.OpenElement(6, "div"); __builder.AddAttribute(7, "class", "node-info");
        __builder.OpenElement(8, "div"); __builder.AddAttribute(9, "class", "node-name"); __builder.AddContent(10, node.Name); __builder.CloseElement();
        __builder.OpenElement(11, "div"); __builder.AddAttribute(12, "class", "node-details");
        if (node.Br.HasValue)
        {
            __builder.OpenElement(13, "span"); __builder.AddAttribute(14, "class", "node-br"); __builder.AddContent(15, $"BR: {node.Br}"); __builder.CloseElement();
        }
        if (node.RequiredExp.HasValue && node.RequiredExp > 0)
        {
            __builder.OpenElement(16, "span"); __builder.AddAttribute(17, "class", "node-exp"); __builder.AddContent(18, $"RP: {node.RequiredExp:N0}"); __builder.CloseElement();
        }
        if (node.SilverCost.HasValue && node.SilverCost > 0)
        {
            __builder.OpenElement(19, "span"); __builder.AddAttribute(20, "class", "node-cost"); __builder.AddContent(21, $"SL: {node.SilverCost:N0}"); __builder.CloseElement();
        }
        __builder.CloseElement(); __builder.CloseElement(); __builder.CloseElement();
    };

    private async Task DrawConnectionLines()
    {
        if (JSRuntime == null || Dependencies == null || !Dependencies.Any()) return;
        try
        {
            var connectionData = Dependencies.Select(dep => new
            {
                lineId = $"dep-{dep.NodeId}-{dep.PrerequisiteNodeId}",
                sourceElementId = $"node-{dep.PrerequisiteNodeId}",
                targetElementId = $"node-{dep.NodeId}"
            }).ToList();
            await JSRuntime.InvokeVoidAsync("techTreeFunctions.drawConnections", connectionData);
        }
        catch
        {
            // Handle JS interop errors silently
        }
    }
}
