@using WTExpCalc.Models
@using WTExpCalc.Services
@inject IExperienceApi Api
@inject IJSRuntime JSRuntime

<div class="tech-tree-container @LoadingState" id="tech-tree-container-id">
    @if (GridNodes.Any())
    {
        <div class="tree-grid" style="@GridStyles">
            @{
                var cumulativeRowsBefore = new Dictionary<int, int>();
                if (MaxRank > 0 && MaxRowIndexPerRank != null)
                {
                    int currentCumulativeRowCount = 0;
                    for (int r = 1; r <= MaxRank; r++)
                    {
                        cumulativeRowsBefore[r] = currentCumulativeRowCount;
                        int rowsInRankR = (MaxRowIndexPerRank.TryGetValue(r, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        currentCumulativeRowCount += rowsInRankR;
                    }
                }

                if (cumulativeRowsBefore != null)
                {
                    @foreach (var rank in Enumerable.Range(1, MaxRank))
                    {
                        int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        int startGridRow = 2 + (cumulativeRowsBefore.TryGetValue(rank, out var cumRows) ? cumRows : 0);
                        string rankLabelStyle = $"grid-column: 1; grid-row: {startGridRow} / span {rowsInThisRank};";
                        var requirement = rankRequirements.FirstOrDefault(r => r.PreviousRank == rank);
                        int requiredCount = requirement?.RequiredUnits ?? 0; 
                        int selectedCount = AllNodesFlat.Count(n => n.Rank == rank && n.Type == "vehicle" && selectedNodeIds.Contains(n.Id)); 

                        <div class="rank-label" style="@rankLabelStyle">
                            <span>Ранг @rank</span>
                            @if (requirement != null)
                            {
                                <span class="rank-requirement-counter @(selectedCount >= requiredCount ? "req-met" : "req-not-met")">
                                    @selectedCount / @requiredCount
                                </span>
                            }
                        </div>
                    }
                }
            }

            @foreach (var node in GridNodes)
            {
                <div @key="node.Id" class="@GetNodeCssClass(node)" style="@GetNodeGridStyle(node)" id="node-container-@node.Id">
                    @if (node.Type == "folder")
                    {
                        @RenderFolderNode(node)
                    }
                    else
                    {
                        @RenderVehicleNode(node)
                    }
                </div>
            }

            <svg class="tree-connections-overlay" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 0;">
                @if (Dependencies != null)
                {
                    @foreach (var dep in Dependencies)
                    {
                        <line id="dep-@dep.NodeId-@dep.PrerequisiteNodeId"
                        x1="0" y1="0" x2="0" y2="0"
                        stroke="#cccccc" stroke-width="2"
                        marker-end="url(#arrowhead)"
                        visibility="hidden" />
                    }
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                        refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#cccccc" />
                        </marker>
                    </defs>
                }
            </svg>
            @{
                var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
                int maxStdColIndex = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
                int standardColumnCount = Math.Max(0, maxStdColIndex + 1);
                int premiumDividerColumn = 2 + standardColumnCount;

                int lastDataRow = 1 + TotalDataGridRows; 

                //Вертикальный разделитель (Премы)
                var premiumNodesExist = AllNodesFlat.Any(n => n.TechCategory != "standard");
                if (premiumNodesExist && standardColumnCount > 0) 
                {
                    string premiumDividerStyle = $"grid-column: {premiumDividerColumn}; grid-row: 2 / {lastDataRow + 1};";
                    <div class="premium-divider-v" style="@premiumDividerStyle"></div>
                }

                //Горизонтальные разделители (Ранги)
                for (int rank = 1; rank < MaxRank; rank++) 
                {
                    int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIdx) ? maxRowIdx : 0) + 1;
                    int startGridRowCurrentRank = 2 + (cumulativeRowsBefore.TryGetValue(rank, out var cumRows) ? cumRows : 0);
                    int endGridRowCurrentRank = startGridRowCurrentRank + rowsInThisRank - 1;

                    string rankDividerStyle = $"grid-column: 2 / -1; grid-row: {endGridRowCurrentRank + 1};";

                    <div class="rank-divider-h" style="@rankDividerStyle"></div>
                }
            }

        </div>
        @if (currentlyExpandedFolder != null)
        {
            <div class="folder-popup-overlay" @onclick="CloseFolderPopup"></div>
        }

        @if (currentlyExpandedFolder != null)
        {
            <div class="folder-popup" id="folder-popup-@currentlyExpandedFolder.Id" style="position:absolute; visibility: hidden;" @key="currentlyExpandedFolder.Id" @onclick:stopPropagation="true">
                <div class="folder-popup-content">
                    @foreach (var child in GetVisualNodesInFolderSequence(currentlyExpandedFolder))
                    {
                        if (child.Type == "vehicle")
                        {
                            <div class="folder-popup-item">
                                @RenderVehicleNode(child)
                            </div>
                        }
                    }
                </div>
            </div>
        }
    }
    else if (LoadingState != "loading")
    {
        <p>Нет данных для отображения.</p>
    }

    @if (LoadingState == "loading")
    {
        <p>Загрузка...</p>
    }
    @if (LoadingState == "error")
    {
        <p style="color: red;">Ошибка загрузки данных!</p>
    }
</div>

@code {
    [Parameter] public int NationId { get; set; }
    [Parameter] public int TypeId { get; set; }
    [Parameter] public EventCallback<TotalsUpdateEventArgs> OnTotalsUpdated { get; set; }

    private List<Node> AllNodesFlat = new();
    private Dictionary<int, Node> NodeLookup = new();
    private List<Node> GridNodes = new();
    private List<NodeDependency> Dependencies = new();
    private Node? currentlyExpandedFolder; 
    private string LoadingState = "loading";
    private List<RankRequirement> rankRequirements = new(); 
    private HashSet<int> selectedNodeIds = new();
    private int MaxRank = 0;
    private string GridStyles = "";
    private Dictionary<int, int> MaxRowIndexPerRank = new();
    private int TotalDataGridRows = 0;
    private long totalSelectedRp = 0;
    private long totalSelectedSl = 0; private int _previousNationId = -1;
    private int _previousTypeId = -1;  
    private bool _isFirstLoad = true;

    public class TotalsUpdateEventArgs : EventArgs
    {
        public long TotalRp { get; set; }
        public long TotalSl { get; set; }
        public string SelectedNames { get; set; } = string.Empty;

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (LoadingState == "loaded" && Dependencies.Any())
        {
            await Task.Delay(50);
            await DrawConnectionLines();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isFirstLoad || NationId != _previousNationId || TypeId != _previousTypeId)
        {
            Console.WriteLine($"[DEBUG] OnParametersSetAsync: Parameters changed or first load. Loading data for NationId={NationId}, TypeId={TypeId}");

            _previousNationId = NationId;
            _previousTypeId = TypeId;
            _isFirstLoad = false;

            await LoadData(); 
        }
        else
        {
            Console.WriteLine($"[DEBUG] OnParametersSetAsync: Parameters NOT changed. Skipping LoadData.");
        }
    }

    private async Task LoadData()
    {
        Console.WriteLine($"[DEBUG] LoadData START for NationId={NationId}, TypeId={TypeId}");

        try
        {
            LoadingState = "loading";
            MaxRowIndexPerRank.Clear();
            GridNodes.Clear();
            Dependencies.Clear();
            rankRequirements.Clear(); 
            selectedNodeIds.Clear();  
            currentlyExpandedFolder = null; 
            StateHasChanged(); 

            AllNodesFlat = await Api.GetAllNodesFlatAsync(NationId, TypeId);
            if (AllNodesFlat == null || !AllNodesFlat.Any())
            {
                MaxRank = 0;
                GridStyles = "";
                LoadingState = "loaded";
                StateHasChanged();
                return;
            }

            rankRequirements = await Api.GetRankRequirementsAsync(NationId, TypeId);

            NodeLookup = AllNodesFlat.ToDictionary(n => n.Id);
            BuildHierarchy();
            PrepareGridNodesAndCalculateRows();
            Dependencies = await Api.GetAllDependenciesAsync(NationId, TypeId);
            CalculateGridDimensions();
            LoadingState = "loaded";
            await CalculateAndUpdateTotals();
        }
        catch (Exception ex)
        {
            totalSelectedRp = 0;
            totalSelectedSl = 0;
            if (OnTotalsUpdated.HasDelegate)
            {
                await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs { TotalRp = 0, TotalSl = 0 });
            }
        }
        StateHasChanged(); 
        Console.WriteLine($"[DEBUG] LoadData END for NationId={NationId}, TypeId={TypeId}");

    }

    private async Task CalculateAndUpdateTotals()
    {
        Console.WriteLine($"[DEBUG] CalculateAndUpdateTotals called. Selected IDs count: {selectedNodeIds.Count}");

        totalSelectedRp = 0;
        totalSelectedSl = 0;
        var nameList = new List<string>();

        foreach (int nodeId in selectedNodeIds)
        {
            if (NodeLookup.TryGetValue(nodeId, out var node))
            {
                long rpValue = node.RequiredExp ?? 0;
                long slValue = node.SilverCost ?? 0;
                totalSelectedRp += rpValue;
                totalSelectedSl += slValue;
                nameList.Add(node.Name);
                Console.WriteLine($"[DEBUG]   - Node ID: {nodeId}, RP: {rpValue}, SL: {slValue}. Current totals: RP={totalSelectedRp}, SL={totalSelectedSl}");
            }
            else
            {
                Console.WriteLine($"[DEBUG]   - Node ID: {nodeId} NOT FOUND in NodeLookup!");
            }
        }
        string namesString = string.Join(", ", nameList); 

        Console.WriteLine($"[DEBUG] Final calculated totals: RP={totalSelectedRp}, SL={totalSelectedSl}");
        Console.WriteLine($"[DEBUG] Selected Names: {namesString}");

        if (OnTotalsUpdated.HasDelegate)
        {
            Console.WriteLine("[DEBUG] OnTotalsUpdated has delegate. Invoking...");
            await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs
                {
                    TotalRp = totalSelectedRp,
                    TotalSl = totalSelectedSl,
                    SelectedNames = namesString 
                });
            Console.WriteLine("[DEBUG] OnTotalsUpdated invoked successfully.");
        }
        else
        {
            Console.WriteLine("[DEBUG] WARNING: OnTotalsUpdated delegate is NOT set in CalculateAndUpdateTotals!"); // Изменили на Warning
        }
    }

    private void BuildHierarchy()
    {
        if (NodeLookup == null || !NodeLookup.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            node.Children.Clear();
            node.ParentNode = null;
            if (node.ParentId.HasValue && NodeLookup.TryGetValue(node.ParentId.Value, out var parent))
            {
                node.ParentNode = parent;
                parent.Children.Add(node);
            }
        }
    }

    private void PrepareGridNodesAndCalculateRows()
    {
        GridNodes.Clear();
        MaxRowIndexPerRank.Clear();
        TotalDataGridRows = 0;

        if (AllNodesFlat == null || !AllNodesFlat.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            int currentMax = MaxRowIndexPerRank.TryGetValue(node.Rank, out var max) ? max : -1;
            if ((node.RowIndex ?? 0) > currentMax) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
            else if (!MaxRowIndexPerRank.ContainsKey(node.Rank)) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
        }
        TotalDataGridRows = MaxRowIndexPerRank.Sum(kvp => kvp.Value + 1);



        foreach (var node in AllNodesFlat)
        {
            bool isGridNode = false;

            if (node.Type == "folder")
            {
                isGridNode = true;
            }
            else if (node.Type == "vehicle")
            {
                if (!node.OrderInFolder.HasValue)
                {
                    isGridNode = true;
                }
            }
            if (isGridNode)
            {
                GridNodes.Add(node);
            }
        }

        Console.WriteLine($"[DEBUG] Prepared GridNodes. Count: {GridNodes.Count}");
    }

    private void CalculateGridDimensions()
    {
        MaxRank = AllNodesFlat.Any() ? AllNodesFlat.Max(n => n.Rank) : 0;
        var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
        int maxStd = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        var premiumNodes = AllNodesFlat.Where(n => n.TechCategory != "standard");
        int maxPrem = premiumNodes.Any() ? premiumNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        int stdCount = Math.Max(0, maxStd + 1);
        int premCount = Math.Max(0, maxPrem + 1);

        string gridRowsStyle = "auto";
        if (TotalDataGridRows > 0)
            gridRowsStyle += $" repeat({TotalDataGridRows}, minmax(80px, auto))";
        else if (MaxRank > 0)
            gridRowsStyle += $" repeat({MaxRank}, minmax(80px, auto))";

        GridStyles =
            $"display: grid; " +
            $"grid-template-rows: {gridRowsStyle}; " +
            $"grid-template-columns: auto {(stdCount > 0 ? $"repeat({stdCount}, minmax(100px, auto)) " : "")}{(premCount > 0 ? $"repeat({premCount}, minmax(100px, auto))" : "")}; " +
            $"gap: 30px 40px; position: relative;";
    }

    private string GetNodeGridStyle(Node node)
    {
        int col = node.TechCategory == "standard"
            ? 1 + (node.ColumnIndex ?? 0) + 1
            : 1 + ((AllNodesFlat.Where(n => n.TechCategory == "standard").Max(n => n.ColumnIndex ?? 0)) + 1) + (node.ColumnIndex ?? 0) + 1;
        int calculatedRow = 1;
        for (int r = 1; r < node.Rank; r++)
            calculatedRow += (MaxRowIndexPerRank.TryGetValue(r, out var prev) ? prev : 0) + 1;
        calculatedRow += (node.RowIndex ?? 0);
        return $"grid-column: {col}; grid-row: {calculatedRow + 1}; z-index:1; position:relative;";
    }

    private string GetNodeCssClass(Node node)
    {
        return $"tree-grid-item node-type-{node.Type} tech-cat-{node.TechCategory}";
    }

    private async Task HandleNodeClick(Node node)
    {
        if (node.Type != "folder") return;

        if (currentlyExpandedFolder?.Id == node.Id)
        {
            currentlyExpandedFolder = null;
        }
        else 
        {
            currentlyExpandedFolder = node;
        }

        StateHasChanged(); 

        if (currentlyExpandedFolder != null)
        {
            await Task.Delay(10);
            try
            {
                await JSRuntime.InvokeVoidAsync("techTreeFunctions.positionFolderPopup",
                    $"folder-popup-{currentlyExpandedFolder.Id}", 
                    $"node-{currentlyExpandedFolder.Id}",      
                    "tech-tree-container-id"                    
                );
            }
            catch (Exception ex) { Console.WriteLine($"JS interop error: {ex.Message}"); }
        }
    }
    private void CloseFolderPopup()
    {
        if (currentlyExpandedFolder != null)
        {
            Console.WriteLine($"[DEBUG] Closing folder ID {currentlyExpandedFolder.Id} via overlay click.");
            currentlyExpandedFolder = null;
            StateHasChanged(); 
        }
    }
    private async Task ToggleNodeSelection(Node node) 
    {
        if (node.Type != "vehicle") return;

        Console.WriteLine($"[DEBUG] ToggleNodeSelection called for Node ID: {node.Id}, Name: {node.Name}");
        if (currentlyExpandedFolder != null) 
        {
            var nodesInCurrentPopup = GetVisualNodesInFolderSequence(currentlyExpandedFolder)
                                        .Where(n => n.Type == "vehicle") 
                                        .Select(n => n.Id)               
                                        .ToHashSet();                    

            if (!nodesInCurrentPopup.Contains(node.Id))
            {
                Console.WriteLine($"[DEBUG] Closing folder ID {currentlyExpandedFolder.Id} because vehicle node {node.Id} (OUTSIDE the folder) was clicked.");
                currentlyExpandedFolder = null;
            }
            else
            {
                Console.WriteLine($"[DEBUG] Clicked node {node.Id} is INSIDE the currently open folder {currentlyExpandedFolder.Id}. Keeping folder open.");
            }
        }
        bool isSelected = selectedNodeIds.Contains(node.Id);
        int initialCount = selectedNodeIds.Count;

        if (isSelected)
        {
            selectedNodeIds.Remove(node.Id);
            Console.WriteLine($"[DEBUG] Node {node.Id} REMOVED from selection.");
        }
        else
        {
            selectedNodeIds.Add(node.Id);
            Console.WriteLine($"[DEBUG] Node {node.Id} ADDED to selection."); 
        }

        Console.WriteLine($"[DEBUG] Selection count changed from {initialCount} to {selectedNodeIds.Count}.");

        await CalculateAndUpdateTotals();

        StateHasChanged(); 
        Console.WriteLine($"[DEBUG] ToggleNodeSelection finished for Node ID: {node.Id}. StateHasChanged called.");
    }

    private bool IsFolderSelected(Node folderNode)
    {
        var children = GetVisualNodesInFolderSequence(folderNode);
        return children.Any(child => child.Type == "vehicle" && selectedNodeIds.Contains(child.Id));
    }

    private RenderFragment RenderFolderNode(Node node) => builder =>
      {
          bool isCurrentlyExpanded = currentlyExpandedFolder?.Id == node.Id;
          bool containsSelected = IsFolderSelected(node); 
          var children = GetVisualNodesInFolderSequence(node)
                    .Where(c => c.Type == "vehicle")
                    .ToList();
          int totalChildren = children.Count;
          int selectedChildrenCount = children.Count(c => selectedNodeIds.Contains(c.Id));

          int seq = 0;

          builder.OpenElement(seq++, "div"); 

          //нужные классы
          builder.AddAttribute(seq++, "class",
          $"node-content folder-node {(isCurrentlyExpanded ? "folder-active" : "")} {(containsSelected ? "folder-contains-selected" : "")}");
          builder.AddAttribute(seq++, "id", $"node-{node.Id}");
          builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => HandleNodeClick(node))); 

          // Иконка
          builder.OpenElement(seq++, "div");
          builder.AddAttribute(seq++, "class", "node-icon");
          builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
          builder.CloseElement(); 

          // Название
          builder.OpenElement(seq++, "div");
          builder.AddAttribute(seq++, "class", "node-name");
          builder.AddContent(seq++, node.Name);
          builder.CloseElement();

          if (totalChildren > 0) 
          {
              builder.OpenElement(seq++, "div");
              builder.AddAttribute(seq++, "class", "folder-child-counter");
              builder.AddContent(seq++, $"{selectedChildrenCount} / {totalChildren}");
              builder.CloseElement();
          }

          // Плюс/минус
          builder.OpenElement(seq++, "div");
          builder.AddAttribute(seq++, "class", "folder-toggle-icon");
          builder.AddContent(seq++, isCurrentlyExpanded ? "−" : "+");
          builder.CloseElement();

          builder.CloseElement(); 
      };

    private List<Node> GetVisualNodesInFolderSequence(Node folderNode)
    {
        return AllNodesFlat
            .Where(n =>
                n.Rank == folderNode.Rank
                && n.ColumnIndex == folderNode.ColumnIndex
                && n.RowIndex == folderNode.RowIndex
                && n.OrderInFolder.HasValue)
            .OrderBy(n => n.OrderInFolder!.Value)
            .ToList();
    }

    private RenderFragment RenderVehicleNode(Node node) => __builder =>
     {
         bool isSelected = selectedNodeIds.Contains(node.Id);
         int seq = 0;

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "id", $"node-{node.Id}"); 

         __builder.AddAttribute(seq++, "class",
         $"node-content vehicle-node {(node.RequiredExp.HasValue ? "rp-editable" : "")} {(isSelected ? "node-selected" : "")}");
         __builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => ToggleNodeSelection(node)));

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-icon");
         __builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
         __builder.CloseElement(); 

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-info");

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-name");
         __builder.AddContent(seq++, node.Name);
         __builder.CloseElement(); 

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-details");

         if (node.Br.HasValue)
         {
             __builder.OpenElement(seq++, "div");
             __builder.AddAttribute(seq++, "class", "node-detail-item node-br");
             __builder.AddContent(seq++, $"BR: {node.Br}");
             __builder.CloseElement(); 
         }

         __builder.OpenElement(seq++, "div");
         __builder.AddAttribute(seq++, "class", "node-detail-item node-exp");
         if (node.RequiredExp.HasValue)
         {
             __builder.AddContent(seq++, "RP: ");
             __builder.OpenElement(seq++, "input");
             __builder.AddAttribute(seq++, "type", "number");
             __builder.AddAttribute(seq++, "class", "rp-input");
             __builder.AddAttribute(seq++, "min", "0");
             __builder.AddAttribute(seq++, "value", BindConverter.FormatValue(node.RequiredExp)); 
             __builder.AddAttribute(seq++, "onchange", EventCallback.Factory.CreateBinder<int?>(this, 
             v => { node.RequiredExp = v; StateHasChanged();}, node.RequiredExp));
             __builder.AddElementReferenceCapture(seq++, capturedRef => { });
             __builder.CloseElement();
         }
         __builder.CloseElement();

         __builder.CloseElement();

         __builder.CloseElement();

         __builder.CloseElement();
     };

    private async Task DrawConnectionLines()
    {
        if (JSRuntime == null || Dependencies == null || !Dependencies.Any()) return;
        try
        {
            var connectionData = Dependencies.Select(dep => new
            {
                lineId = $"dep-{dep.NodeId}-{dep.PrerequisiteNodeId}",
                sourceElementId = $"node-{dep.PrerequisiteNodeId}",
                targetElementId = $"node-{dep.NodeId}"
            }).ToList();
            await JSRuntime.InvokeVoidAsync("techTreeFunctions.drawConnections", connectionData);
        }
        catch
        {
            
        }
    }
}
