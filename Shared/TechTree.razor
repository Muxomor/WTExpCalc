@using WTExpCalc.Models
@using WTExpCalc.Services
@inject IExperienceApi Api
@inject IJSRuntime JSRuntime
@inject IUrlStateManager UrlStateManager
@inject NavigationManager Navigation
@inject ILocalizationService Localization

<div class="tech-tree-container @LoadingState" id="tech-tree-container-id">
    @if (GridNodes.Any())
    {
                                <div class="tree-grid" style="@GridStyles">
            @{
                var activeRanks = GetActiveRanks();
                var cumulativeRowsBefore = new Dictionary<int, int>();

                if (activeRanks.Any() && MaxRowIndexPerRank != null)
                {
                    int currentCumulativeRowCount = 0;
                    foreach (var rank in activeRanks)
                    {
                        cumulativeRowsBefore[rank] = currentCumulativeRowCount;
                        int rowsInRankR = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                        currentCumulativeRowCount += rowsInRankR;
                    }
                }

                // Отрисовываем только активные ранги
                foreach (var rank in activeRanks)
                {
                    int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(rank, out var maxRowIndex) ? maxRowIndex : 0) + 1;
                    int startGridRow = 2 + (cumulativeRowsBefore.TryGetValue(rank, out var cumRows) ? cumRows : 0);
                    string rankLabelStyle = $"grid-column: 1; grid-row: {startGridRow} / span {rowsInThisRank};";
                    var requirement = rankRequirements.FirstOrDefault(r => r.PreviousRank == rank);
                    int requiredCount = requirement?.RequiredUnits ?? 0;
                    int selectedCount = AllNodesFlat.Count(n => n.Rank == rank && n.Type == "vehicle" && selectedNodeIds.Contains(n.Id)); 

                                                                                            <div class="rank-label" style="@rankLabelStyle">
                                                                                                      <span>@Localization.GetText("Rank") @rank</span>
                        @if (requirement != null)
                        {
                                                                                                                            <span class="rank-requirement-counter @(selectedCount >= requiredCount ? "req-met" : "req-not-met")">
                                @selectedCount / @requiredCount
                                                                                                                            </span>
                        }
                                                                                            </div>
                }
            }

            @foreach (var node in GridNodes)
            {
                                                                <div @key="node.Id" class="@GetNodeCssClass(node)" style="@GetNodeGridStyle(node)" id="node-container-@node.Id">
                    @if (node.Type == "folder")
                    {
                        @RenderFolderNode(node)
                    }
                    else
                    {
                        @RenderVehicleNode(node)
                    }
                                                                </div>
            }

                                    <svg class="tree-connections-overlay" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 0;">
                @if (Dependencies != null)
                {
                    @foreach (var dep in Dependencies)
                    {
                                                                                                <line id="dep-@dep.NodeId-@dep.PrerequisiteNodeId"
                                                                                                x1="0" y1="0" x2="0" y2="0"
                                                                                                stroke="#cccccc" stroke-width="2"
                                                                                                marker-end="url(#arrowhead)"
                                                                                                visibility="hidden" />
                    }
                                                                    <defs>
                                                                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                                                                        refX="10" refY="3.5" orient="auto">
                                                                            <polygon points="0 0, 10 3.5, 0 7" fill="#cccccc" />
                                                                        </marker>
                                                                    </defs>
                }
                                    </svg>
            @{
                var ranksForDividers = GetActiveRanks();
                var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
                int maxStdColIndex = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
                int standardColumnCount = Math.Max(0, maxStdColIndex + 1);
                int premiumDividerColumn = 2 + standardColumnCount;

                int lastDataRow = 1 + TotalDataGridRows;

                //Вертикальный разделитель (Премы)
                var premiumNodesExist = AllNodesFlat.Any(n => n.TechCategory != "standard");
                if (premiumNodesExist && standardColumnCount > 0)
                {
                    string premiumDividerStyle = $"grid-column: {premiumDividerColumn}; grid-row: 2 / {lastDataRow + 1};";
                                                                                            <div class="premium-divider-v" style="@premiumDividerStyle"></div>
                }

                //Горизонтальные разделители (только между активными рангами)
                for (int i = 0; i < ranksForDividers.Count - 1; i++)
                {
                    var currentRank = ranksForDividers[i];
                    int rowsInThisRank = (MaxRowIndexPerRank.TryGetValue(currentRank, out var maxRowIdx) ? maxRowIdx : 0) + 1;
                    int startGridRowCurrentRank = 2 + (cumulativeRowsBefore.TryGetValue(currentRank, out var cumRows) ? cumRows : 0);
                    int endGridRowCurrentRank = startGridRowCurrentRank + rowsInThisRank - 1;

                    string rankDividerStyle = $"grid-column: 2 / -1; grid-row: {endGridRowCurrentRank + 1};";
                                                                                            <div class="rank-divider-h" style="@rankDividerStyle"></div>
                }
            }

                                </div>
        @if (currentlyExpandedFolder != null)
        {
                                                            <div class="folder-popup-overlay" @onclick="CloseFolderPopup"></div>
        }

        @if (currentlyExpandedFolder != null)
        {
                                                            <div class="folder-popup" id="folder-popup-@currentlyExpandedFolder.Id" style="position:absolute; visibility: hidden;" @key="currentlyExpandedFolder.Id" @onclick:stopPropagation="true">
                                                                <div class="folder-popup-content">
                    @foreach (var child in GetVisualNodesInFolderSequence(currentlyExpandedFolder))
                    {
                        if (child.Type == "vehicle")
                        {
                                                                                                                            <div class="folder-popup-item">
                                @RenderVehicleNode(child)
                                                                                                                            </div>
                        }
                    }
                                                                </div>
                                                            </div>
        }
    }
    else if (LoadingState != "loading")
    {
                                    <p>@Localization.GetText("NoVehicleTypes")</p>
    }

    @if (LoadingState == "loading")
    {
                                <p>@Localization.GetText("Loading")</p>
    }
    @if (LoadingState == "error")
    {
                                <p style="color: red;">@Localization.GetText("Error")</p>
    }
</div>

@code {
    [Parameter] public int NationId { get; set; }
    [Parameter] public int TypeId { get; set; }
    [Parameter] public EventCallback<TotalsUpdateEventArgs> OnTotalsUpdated { get; set; }
    [Parameter] public EventCallback<List<int>> OnSelectedRanksChanged { get; set; }

    private List<Node> AllNodesFlat = new();
    private Dictionary<int, Node> NodeLookup = new();
    private List<Node> GridNodes = new();
    private List<NodeDependency> Dependencies = new();
    private Node? currentlyExpandedFolder;
    private string LoadingState = "loading";
    private List<RankRequirement> rankRequirements = new();
    private HashSet<int> selectedNodeIds = new();
    private int MaxRank = 0;
    private string GridStyles = "";
    private Dictionary<int, int> MaxRowIndexPerRank = new();
    private int TotalDataGridRows = 0;
    private long totalSelectedRp = 0;
    private long totalSelectedSl = 0;

    // Словарь для хранения исходных значений RP
    private Dictionary<int, int?> originalRpValues = new();
    // Флаг для предотвращения циклических обновлений URL
    private bool _suppressUrlUpdate = false;

    private int _previousNationId = -1;
    private int _previousTypeId = -1;
    private bool _isFirstLoad = true;

    public class TotalsUpdateEventArgs : EventArgs
    {
        public long TotalRp { get; set; }
        public long TotalSl { get; set; }
        public string SelectedNames { get; set; } = string.Empty;
        public string FormattedText { get; set; } = string.Empty;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (LoadingState == "loaded" && Dependencies.Any())
        {
            await Task.Delay(50);
            await DrawConnectionLines();
        }
    }
    protected override async Task OnParametersSetAsync()
    {
        // Подписываемся на изменение языка только один раз
        if (_isFirstLoad)
        {
            Localization.LanguageChanged += OnLanguageChanged;
        }

        if (_isFirstLoad || NationId != _previousNationId || TypeId != _previousTypeId)
        {
            _previousNationId = NationId;
            _previousTypeId = TypeId;
            _isFirstLoad = false;

            await LoadData();
        }
    }
    private void OnLanguageChanged()
    {
        // ВАЖНО: Пересчитываем итоги при смене языка для корректного копирования
        InvokeAsync(async () =>
        {
            await CalculateAndUpdateTotals();
            StateHasChanged();
        });
    }
    private string GetNodeDisplayName(Node node)
    {
        return SimpleGameLocalization.GetNodeName(node.Name, node.NameEnglish, Localization.IsEnglish);
    }

    private async Task LoadData()
    {
        try
        {
            LoadingState = "loading";
            _suppressUrlUpdate = true; // Предотвращаем обновление URL во время загрузки

            MaxRowIndexPerRank.Clear();
            GridNodes.Clear();
            Dependencies.Clear();
            rankRequirements.Clear();
            selectedNodeIds.Clear();
            originalRpValues.Clear();
            currentlyExpandedFolder = null;
            StateHasChanged();

            AllNodesFlat = await Api.GetAllNodesFlatAsync(NationId, TypeId);
            if (AllNodesFlat == null || !AllNodesFlat.Any())
            {
                MaxRank = 0;
                GridStyles = "";
                LoadingState = "loaded";
                _suppressUrlUpdate = false;
                StateHasChanged();
                return;
            }

            // Сохраняем исходные значения RP
            foreach (var node in AllNodesFlat)
            {
                if (node.RequiredExp.HasValue)
                {
                    originalRpValues[node.Id] = node.RequiredExp.Value;
                }
            }

            rankRequirements = await Api.GetRankRequirementsAsync(NationId, TypeId);
            NodeLookup = AllNodesFlat.ToDictionary(n => n.Id);
            PrepareGridNodesAndCalculateRows();
            Dependencies = await Api.GetAllDependenciesAsync(NationId, TypeId);
            CalculateGridDimensions();

            // Восстанавливаем состояние из URL
            await RestoreStateFromUrl();

            LoadingState = "loaded";
            _suppressUrlUpdate = false; // Разрешаем обновление URL

            await CalculateAndUpdateTotals();
        }
        catch (Exception ex)
        {
            totalSelectedRp = 0;
            totalSelectedSl = 0;
            _suppressUrlUpdate = false;

            if (OnTotalsUpdated.HasDelegate)
            {
                await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs { TotalRp = 0, TotalSl = 0 });
            }
        }
        StateHasChanged();
    }

    private async Task RestoreStateFromUrl()
    {
        try
        {
            var currentUrl = Navigation.Uri;
            var urlState = await UrlStateManager.RestoreSelectionFromUrlAsync(AllNodesFlat, currentUrl);

            selectedNodeIds = urlState.SelectedNodeIds;

            // Восстанавливаем измененные значения RP
            foreach (var kvp in urlState.ModifiedRpValues)
            {
                if (NodeLookup.TryGetValue(kvp.Key, out var node))
                {
                    node.RequiredExp = kvp.Value;
                }
            }

            Console.WriteLine($"Restored state: {selectedNodeIds.Count} selected nodes, {urlState.ModifiedRpValues.Count} RP modifications");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error restoring state from URL: {ex.Message}");
        }
    }

    private async Task UpdateUrlState()
    {
        if (_suppressUrlUpdate || LoadingState != "loaded") return;

        try
        {
            UrlStateManager.UpdateUrlWithSelection(AllNodesFlat, selectedNodeIds, originalRpValues);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating URL state: {ex.Message}");
        }
    }
    private async Task CalculateAndUpdateTotals()
{
    totalSelectedRp = 0;
    totalSelectedSl = 0;
    var nameList = new List<string>();

    // ИСПРАВЛЕНО: Получаем ВСЕ выбранные узлы типа "vehicle", не только с опытом
    var allSelectedNodes = selectedNodeIds
        .Select(id => NodeLookup.TryGetValue(id, out var node) ? node : null)
        .Where(node => node != null && node.Type == "vehicle") // Убрали фильтр по RequiredExp
        .ToList();

    Console.WriteLine($"=== CalculateAndUpdateTotals DEBUG ===");
    Console.WriteLine($"Total selected node IDs: {selectedNodeIds.Count}");
    Console.WriteLine($"All selected vehicle nodes: {allSelectedNodes.Count}");

    // Отладка: выводим все выбранные узлы
    foreach (var node in allSelectedNodes)
    {
        Console.WriteLine($"Selected node: {GetNodeDisplayName(node!)}, Category: '{node!.TechCategory}', HasRP: {node.RequiredExp.HasValue}");
    }

    // Подсчитываем опыт и SL только для узлов с опытом
    var nodesWithRp = allSelectedNodes.Where(node => node!.RequiredExp.HasValue).ToList();

    foreach (var node in nodesWithRp)
    {
        long rpValue = node!.RequiredExp ?? 0;
        long slValue = node.SilverCost ?? 0;
        totalSelectedRp += rpValue;
        totalSelectedSl += slValue;
    }

    Console.WriteLine($"Nodes with RP: {nodesWithRp.Count}, Total RP: {totalSelectedRp}");

    // Для отображения имен используем ВСЕ выбранные узлы
    foreach (var node in allSelectedNodes)
    {
        nameList.Add(GetNodeDisplayName(node!));
    }

    string namesString = string.Join(", ", nameList);
    
    // ИСПРАВЛЕНО: Передаем ВСЕ выбранные узлы в форматирование, не только с RP
    string formattedText = FormatVehicleListForCopy(allSelectedNodes!);

    Console.WriteLine($"Names for display: {namesString}");
    Console.WriteLine($"Formatted text length: {formattedText.Length}");

    if (OnTotalsUpdated.HasDelegate)
    {
        await OnTotalsUpdated.InvokeAsync(new TotalsUpdateEventArgs
            {
                TotalRp = totalSelectedRp,
                TotalSl = totalSelectedSl,
                SelectedNames = namesString,
                FormattedText = formattedText
            });
    }

    // Уведомляем родительский компонент об изменении выбранных рангов
    if (OnSelectedRanksChanged.HasDelegate)
    {
        var selectedRanks = GetSelectedRanks();
        await OnSelectedRanksChanged.InvokeAsync(selectedRanks);
    }
}
 private string FormatVehicleListForCopy(List<Node> selectedNodes)
{
    if (!selectedNodes.Any()) return "";

    foreach (var node in selectedNodes)
    {
        Console.WriteLine($"Node: {GetNodeDisplayName(node)}, Category: '{node.TechCategory}', Type: '{node.Type}'");
    }

    // Разделяем стандартную и премиумную технику
    var standardNodes = selectedNodes.Where(n => n.TechCategory == "standard").ToList();
    var premiumNodes = selectedNodes.Where(n => n.TechCategory != "standard").ToList();

    Console.WriteLine($"Standard nodes: {standardNodes.Count}, Premium nodes: {premiumNodes.Count}");

    var result = new List<string>();

    // Обрабатываем стандартную технику (группируем по рангам)
    if (standardNodes.Any())
    {
        var groupedByRank = standardNodes
            .GroupBy(n => n.Rank)
            .OrderBy(g => g.Key)
            .ToList();

        foreach (var rankGroup in groupedByRank)
        {
            var rankNumber = rankGroup.Key;
            var vehiclesInRank = rankGroup
                .OrderBy(n => n.ColumnIndex ?? 0)
                .ToList();

            var vehicleNames = new List<string>();

            foreach (var vehicle in vehiclesInRank)
            {
                string vehicleName = GetNodeDisplayName(vehicle);

                // Проверяем, изменено ли значение RP только для стандартной техники
                if (IsRpValueModified(vehicle))
                {
                    var currentRp = vehicle.RequiredExp ?? 0;
                    var originalRp = originalRpValues.TryGetValue(vehicle.Id, out var orig) ? orig ?? 0 : 0;
                    vehicleName += $" ({currentRp} / {originalRp})";
                }

                vehicleNames.Add(vehicleName);
            }

            // Формируем строку для ранга с учетом языка
            string rankLine = $"{Localization.GetText("Rank")} {ToRomanNumeral(rankNumber)}:\n{string.Join(", ", vehicleNames)}";
            result.Add(rankLine);
        }
    }

    // Добавляем премиумную технику простым списком через запятую
    if (premiumNodes.Any())
    {
        Console.WriteLine("=== Adding premium vehicles ===");
        var premiumNames = new List<string>();

        foreach (var vehicle in premiumNodes.OrderBy(n => n.Rank).ThenBy(n => n.ColumnIndex ?? 0))
        {
            // Для премиумной техники берем ТОЛЬКО локализованное имя, без RP
            string vehicleName = GetNodeDisplayName(vehicle);
            premiumNames.Add(vehicleName);
            Console.WriteLine($"Added premium: {vehicleName}");
        }

        // Добавляем премиумную технику как отдельную секцию
        string premiumText = string.Join(", ", premiumNames);
        result.Add(premiumText);
        Console.WriteLine($"Premium section: {premiumText}");
    }

    // Добавляем общее количество опыта в конец
    string totalRpText = $"{Localization.GetText("TotalRP")}: {totalSelectedRp:N0}";

    var finalResult = string.Join("\n\n", result) + (result.Any() ? "\n\n" + totalRpText : totalRpText);
    Console.WriteLine($"=== Final formatted text ===\n{finalResult}");
    
    return finalResult;
}
    private string ToRomanNumeral(int number)
    {
        return number switch
        {
            1 => "I",
            2 => "II",
            3 => "III",
            4 => "IV",
            5 => "V",
            6 => "VI",
            7 => "VII",
            8 => "VIII",
            _ => number.ToString()
        };
    }

    private void PrepareGridNodesAndCalculateRows()
    {
        GridNodes.Clear();
        MaxRowIndexPerRank.Clear();
        TotalDataGridRows = 0;

        if (AllNodesFlat == null || !AllNodesFlat.Any()) return;

        foreach (var node in AllNodesFlat)
        {
            int currentMax = MaxRowIndexPerRank.TryGetValue(node.Rank, out var max) ? max : -1;
            if ((node.RowIndex ?? 0) > currentMax) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
            else if (!MaxRowIndexPerRank.ContainsKey(node.Rank)) MaxRowIndexPerRank[node.Rank] = node.RowIndex ?? 0;
        }
        TotalDataGridRows = MaxRowIndexPerRank.Sum(kvp => kvp.Value + 1);

        foreach (var node in AllNodesFlat)
        {
            bool isGridNode = false;

            if (node.Type == "folder")
            {
                isGridNode = true;
            }
            else if (node.Type == "vehicle")
            {
                if (!node.OrderInFolder.HasValue)
                {
                    isGridNode = true;
                }
            }
            if (isGridNode)
            {
                GridNodes.Add(node);
            }
        }
    }

    private void CalculateGridDimensions()
    {
        MaxRank = AllNodesFlat.Any() ? AllNodesFlat.Max(n => n.Rank) : 0;
        var standardNodes = AllNodesFlat.Where(n => n.TechCategory == "standard");
        int maxStd = standardNodes.Any() ? standardNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        var premiumNodes = AllNodesFlat.Where(n => n.TechCategory != "standard");
        int maxPrem = premiumNodes.Any() ? premiumNodes.Max(n => n.ColumnIndex ?? 0) : -1;
        int stdCount = Math.Max(0, maxStd + 1);
        int premCount = Math.Max(0, maxPrem + 1);

        string gridRowsStyle = "auto";
        if (TotalDataGridRows > 0)
            gridRowsStyle += $" repeat({TotalDataGridRows}, minmax(80px, auto))";
        else if (MaxRank > 0)
            gridRowsStyle += $" repeat({MaxRank}, minmax(80px, auto))";

        GridStyles =
            $"display: grid; " +
            $"grid-template-rows: {gridRowsStyle}; " +
            $"grid-template-columns: 60px {(stdCount > 0 ? $"repeat({stdCount}, minmax(100px, auto)) " : "")}{(premCount > 0 ? $"repeat({premCount}, minmax(100px, auto))" : "")}; " +
            $"gap: 30px 40px; position: relative;";
    }

    private List<int> GetActiveRanks()
    {
        // Получаем ранги из rankRequirements и из техники
        var ranksFromRequirements = rankRequirements.Select(r => r.PreviousRank).ToHashSet();
        var ranksFromNodes = AllNodesFlat.Select(n => n.Rank).ToHashSet();

        // Объединяем и сортируем
        var allActiveRanks = ranksFromRequirements.Union(ranksFromNodes).OrderBy(r => r).ToList();

        return allActiveRanks;
    }

    private string GetNodeGridStyle(Node node)
    {
        var activeRanks = GetActiveRanks();

        int col = node.TechCategory == "standard"
            ? 1 + (node.ColumnIndex ?? 0) + 1
            : 1 + ((AllNodesFlat.Where(n => n.TechCategory == "standard").Max(n => n.ColumnIndex ?? 0)) + 1) + (node.ColumnIndex ?? 0) + 1;

        // Вычисляем строку на базе активных рангов
        int calculatedRow = 1;
        foreach (var activeRank in activeRanks)
        {
            if (activeRank >= node.Rank) break;
            calculatedRow += (MaxRowIndexPerRank.TryGetValue(activeRank, out var prev) ? prev : 0) + 1;
        }
        calculatedRow += (node.RowIndex ?? 0);

        return $"grid-column: {col}; grid-row: {calculatedRow + 1}; z-index:1; position:relative;";
    }

    private string GetNodeCssClass(Node node)
    {
        return $"tree-grid-item node-type-{node.Type} tech-cat-{node.TechCategory}";
    }

    private async Task HandleNodeClick(Node node)
    {
        if (node.Type != "folder") return;

        if (currentlyExpandedFolder?.Id == node.Id)
        {
            currentlyExpandedFolder = null;
        }
        else
        {
            currentlyExpandedFolder = node;
        }

        StateHasChanged();

        if (currentlyExpandedFolder != null)
        {
            await Task.Delay(10);
            try
            {
                await JSRuntime.InvokeVoidAsync("techTreeFunctions.positionFolderPopup",
                    $"folder-popup-{currentlyExpandedFolder.Id}",
                    $"node-{currentlyExpandedFolder.Id}",
                    "tech-tree-container-id"
                );
            }
            catch (Exception ex) { }
        }
    }

    private void CloseFolderPopup()
    {
        if (currentlyExpandedFolder != null)
        {
            currentlyExpandedFolder = null;
            StateHasChanged();
        }
    }
    private async Task ToggleNodeSelection(Node node)
    {
        if (node.Type != "vehicle") return;

        if (currentlyExpandedFolder != null)
        {
            var nodesInCurrentPopup = GetVisualNodesInFolderSequence(currentlyExpandedFolder)
                                        .Where(n => n.Type == "vehicle")
                                        .Select(n => n.Id)
                                        .ToHashSet();

            if (!nodesInCurrentPopup.Contains(node.Id))
            {
                currentlyExpandedFolder = null;
            }
        }

        bool isSelected = selectedNodeIds.Contains(node.Id);

        if (isSelected)
        {
            selectedNodeIds.Remove(node.Id);
        }
        else
        {
            selectedNodeIds.Add(node.Id);
        }

        // ИСПРАВЛЕНО: пересчитываем итоги с учетом текущего языка
        await CalculateAndUpdateTotals();
        await UpdateUrlState();
        StateHasChanged();
    }

    private bool IsFolderSelected(Node folderNode)
    {
        var children = GetVisualNodesInFolderSequence(folderNode);
        return children.Any(child => child.Type == "vehicle" && selectedNodeIds.Contains(child.Id));
    }
    private RenderFragment RenderFolderNode(Node node) => builder =>
    {
        bool isCurrentlyExpanded = currentlyExpandedFolder?.Id == node.Id;
        bool containsSelected = IsFolderSelected(node);
        var children = GetVisualNodesInFolderSequence(node)
                    .Where(c => c.Type == "vehicle")
                    .ToList();
        int totalChildren = children.Count;
        int selectedChildrenCount = children.Count(c => selectedNodeIds.Contains(c.Id));

        int seq = 0;

        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class",
            $"node-content folder-node {(isCurrentlyExpanded ? "folder-active" : "")} {(containsSelected ? "folder-contains-selected" : "")}");
        builder.AddAttribute(seq++, "id", $"node-{node.Id}");
        builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => HandleNodeClick(node)));

        // Иконка
        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class", "node-icon");
        builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
        builder.CloseElement();

        // ИСПРАВЛЕНО: название папки с локализацией
        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class", "node-name");
        builder.AddContent(seq++, GetNodeDisplayName(node));
        builder.CloseElement();

        if (totalChildren > 0)
        {
            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", "folder-child-counter");
            builder.AddContent(seq++, $"{selectedChildrenCount} / {totalChildren}");
            builder.CloseElement();
        }

        // Плюс/минус
        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class", "folder-toggle-icon");
        builder.AddContent(seq++, isCurrentlyExpanded ? "−" : "+");
        builder.CloseElement();

        builder.CloseElement();
    };

    private List<Node> GetVisualNodesInFolderSequence(Node folderNode)
    {
        return AllNodesFlat
            .Where(n =>
                n.Rank == folderNode.Rank
                && n.ColumnIndex == folderNode.ColumnIndex
                && n.RowIndex == folderNode.RowIndex
                && n.OrderInFolder.HasValue)
            .OrderBy(n => n.OrderInFolder!.Value)
            .ToList();
    }

    private bool IsRpValueModified(Node node)
    {
        if (!node.RequiredExp.HasValue) return false;

        if (originalRpValues.TryGetValue(node.Id, out var originalValue))
        {
            return node.RequiredExp.Value != originalValue;
        }

        return false;
    }

    private async Task OnRpValueChanged(Node node, ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newValue))
        {
            node.RequiredExp = newValue;
            await CalculateAndUpdateTotals();
            await UpdateUrlState(); // Обновляем URL после изменения RP
            StateHasChanged();
        }
    }
    private RenderFragment RenderVehicleNode(Node node) => __builder =>
    {
        bool isSelected = selectedNodeIds.Contains(node.Id);
        bool isRpModified = IsRpValueModified(node);
        int seq = 0;

        __builder.OpenElement(seq++, "div");
        __builder.AddAttribute(seq++, "id", $"node-{node.Id}");
        __builder.AddAttribute(seq++, "class",
            $"node-content vehicle-node {(node.RequiredExp.HasValue ? "rp-editable" : "")} {(isSelected ? "node-selected" : "")}");
        __builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => ToggleNodeSelection(node)));

        __builder.OpenElement(seq++, "div");
        __builder.AddAttribute(seq++, "class", "node-icon");
        __builder.AddAttribute(seq++, "style", $"background-image:url('{node.ImageUrl}')");
        __builder.CloseElement();

        __builder.OpenElement(seq++, "div");
        __builder.AddAttribute(seq++, "class", "node-info");

        __builder.OpenElement(seq++, "div");
        __builder.AddAttribute(seq++, "class", "node-name");
        // ИСПРАВЛЕНО: используем локализованное название
        __builder.AddContent(seq++, GetNodeDisplayName(node));
        __builder.CloseElement();

        __builder.OpenElement(seq++, "div");
        __builder.AddAttribute(seq++, "class", "node-details");

        if (node.Br.HasValue)
        {
            __builder.OpenElement(seq++, "div");
            __builder.AddAttribute(seq++, "class", "node-detail-item node-br");
            // ИСПРАВЛЕНО: используем локализованную метку БР
            __builder.AddContent(seq++, $"{Localization.GetText("BR")}: {node.Br}");
            __builder.CloseElement();
        }

        __builder.OpenElement(seq++, "div");
        __builder.AddAttribute(seq++, "class", "node-detail-item node-exp");
        if (node.RequiredExp.HasValue)
        {
            // ИСПРАВЛЕНО: используем локализованную метку ОИ/RP
            __builder.AddContent(seq++, $"{Localization.GetText("RP")}: ");
            __builder.OpenElement(seq++, "input");
            __builder.AddAttribute(seq++, "type", "number");
            __builder.AddAttribute(seq++, "class", $"rp-input {(isRpModified ? "rp-modified" : "")}");
            __builder.AddAttribute(seq++, "min", "0");
            __builder.AddAttribute(seq++, "value", BindConverter.FormatValue(node.RequiredExp));
            __builder.AddAttribute(seq++, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(this,
                e => OnRpValueChanged(node, e)));
            __builder.AddAttribute(seq++, "onclick", "event.stopPropagation();");
            __builder.AddElementReferenceCapture(seq++, capturedRef => { });
            __builder.CloseElement();
        }
        __builder.CloseElement();

        __builder.CloseElement();
        __builder.CloseElement();
        __builder.CloseElement();
    };

    private async Task DrawConnectionLines()
    {
        if (JSRuntime == null || Dependencies == null || !Dependencies.Any()) return;
        try
        {
            var connectionData = Dependencies.Select(dep => new
            {
                lineId = $"dep-{dep.NodeId}-{dep.PrerequisiteNodeId}",
                sourceElementId = $"node-{dep.PrerequisiteNodeId}",
                targetElementId = $"node-{dep.NodeId}"
            }).ToList();
            await JSRuntime.InvokeVoidAsync("techTreeFunctions.drawConnections", connectionData);
        }
        catch
        {
        }
    }

    // Публичные методы для скриншотов
    public async Task CopyScreenshotToClipboard()
    {
        try
        {
            var selectedRanks = GetSelectedRanks();
            if (!selectedRanks.Any())
            {
                Console.WriteLine("No ranks selected for screenshot");
                return;
            }

            var progressCallback = DotNetObjectReference.Create(this);
            var completeCallback = DotNetObjectReference.Create(this);

            await JSRuntime.InvokeVoidAsync("techTreeFunctions.copyScreenshotToClipboard",
                selectedRanks.ToArray(),
                progressCallback,
                completeCallback);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error copying screenshot to clipboard: {ex.Message}");
        }
    }

    public async Task DownloadScreenshot()
    {
        try
        {
            var selectedRanks = GetSelectedRanks();
            if (!selectedRanks.Any())
            {
                Console.WriteLine("No ranks selected for screenshot");
                return;
            }

            var filename = await JSRuntime.InvokeAsync<string>("techTreeFunctions.generateScreenshotFilename");
            var progressCallback = DotNetObjectReference.Create(this);
            var completeCallback = DotNetObjectReference.Create(this);

            await JSRuntime.InvokeVoidAsync("techTreeFunctions.downloadScreenshot",
                selectedRanks.ToArray(),
                filename,
                progressCallback,
                completeCallback);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error downloading screenshot: {ex.Message}");
        }
    }

    private List<int> GetSelectedRanks()
    {
        return selectedNodeIds
            .Select(id => NodeLookup.TryGetValue(id, out var node) ? node?.Rank : null)
            .Where(rank => rank.HasValue)
            .Select(rank => rank!.Value)
            .Distinct()
            .OrderBy(rank => rank)
            .ToList();
    }

    [JSInvokable]
    public void OnScreenshotProgress(string message)
    {
        // Этот метод может быть вызван из JavaScript для обновления прогресса
        Console.WriteLine($"Screenshot progress: {message}");
    }

    [JSInvokable]
    public void OnScreenshotComplete(bool success, string message)
    {
        Console.WriteLine($"Screenshot complete: {success} - {message}");
    }

    public void Dispose()
    {
        Localization.LanguageChanged -= OnLanguageChanged;
    }
}